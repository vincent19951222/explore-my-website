<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æé¢æ¡çš„åŠ¨ç‰©å›­ - Merry Christmas!</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Press Start 2P', 'Courier New', monospace;
            overflow: hidden;
            background: linear-gradient(180deg, #0a0a1a 0%, #1a1a3a 50%, #2a1a4a 100%);
            cursor: crosshair;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }

        /* æ ‡é¢˜å®¹å™¨ - åƒç´ éœ“è™¹æ•ˆæœ */
        .title-container {
            position: fixed;
            top: 3%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }

        .main-title {
            font-size: clamp(16px, 4vw, 36px);
            color: #ffd700;
            text-shadow:
                3px 3px 0 #ff0000,
                -2px -2px 0 #00ff00,
                0 0 10px #ffd700,
                0 0 20px #ff0000,
                0 0 30px #00ff00;
            animation: titleGlow 2s ease-in-out infinite alternate;
            letter-spacing: 3px;
            margin-bottom: 8px;
            image-rendering: pixelated;
        }

        .subtitle {
            font-size: clamp(10px, 2vw, 18px);
            color: #00ff00;
            text-shadow:
                2px 2px 0 #ff0000,
                0 0 10px #00ff00,
                0 0 15px #ffd700;
            animation: subtitleBlink 1s ease-in-out infinite alternate;
            letter-spacing: 2px;
            image-rendering: pixelated;
        }

        @keyframes titleGlow {
            0% {
                text-shadow:
                    3px 3px 0 #ff0000,
                    -2px -2px 0 #00ff00,
                    0 0 10px #ffd700,
                    0 0 20px #ff0000;
            }
            100% {
                text-shadow:
                    3px 3px 0 #ff0000,
                    -2px -2px 0 #00ff00,
                    0 0 20px #ffd700,
                    0 0 40px #ff0000,
                    0 0 60px #00ff00;
            }
        }

        @keyframes subtitleBlink {
            0% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        /* RPG é£æ ¼å¯¹è¯æ¡†ç³»ç»Ÿ */
        .rpg-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            image-rendering: pixelated;
        }

        .rpg-overlay.show {
            display: flex;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* å·¦ä¾§è§’è‰²ä¿¡æ¯å¡ç‰‡ */
        .character-info-card {
            position: fixed;
            left: 3%;
            top: 50%;
            transform: translateY(-50%) scale(0);
            width: 280px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 4px solid #ffd700;
            padding: 20px;
            z-index: 2002;
            image-rendering: pixelated;
            box-shadow:
                0 0 0 4px #000,
                0 0 30px rgba(255, 215, 0, 0.4),
                inset 0 0 30px rgba(255, 215, 0, 0.1);
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .character-info-card.show {
            transform: translateY(-50%) scale(1);
        }

        .character-info-card::before {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            background: linear-gradient(45deg, #ff6b6b, #ffd700, #4ecdc4, #ff6b6b);
            background-size: 300% 300%;
            z-index: -1;
            animation: cardBorderGlow 4s ease infinite;
        }

        @keyframes cardBorderGlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .info-card-title {
            font-size: 14px;
            color: #ffd700;
            text-align: center;
            margin-bottom: 15px;
            text-shadow: 2px 2px 0 #ff0000;
            border-bottom: 2px dashed #ffd700;
            padding-bottom: 10px;
        }

        .info-card-stats {
            margin-top: 15px;
        }

        .info-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 9px;
        }

        .info-stat-label {
            color: #4ecdc4;
            text-transform: uppercase;
        }

        .info-stat-value {
            color: #fff;
            text-shadow: 1px 1px 0 #000;
        }

        .stat-bar {
            width: 100%;
            height: 8px;
            background: #0a0a1a;
            border: 2px solid #333;
            margin-top: 4px;
            position: relative;
        }

        .stat-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ff6b6b);
            transition: width 1s ease-out;
        }

        /* ä¸»å¯¹è¯æ¡†å®¹å™¨ */
        .rpg-dialog-container {
            position: fixed;
            bottom: 5%;
            left: 50%;
            transform: translateX(-50%) scale(0);
            width: 90%;
            max-width: 900px;
            z-index: 2001;
            image-rendering: pixelated;
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .rpg-dialog-container.show {
            transform: translateX(-50%) scale(1);
        }

        /* å¤´åƒåŒºåŸŸ */
        .dialog-avatar {
            position: absolute;
            left: -3px;
            bottom: -3px;
            width: 150px;
            height: 150px;
            background: #000;
            border: 4px solid #ffd700;
            image-rendering: pixelated;
            box-shadow:
                4px 4px 0 #000,
                0 0 20px rgba(255, 215, 0, 0.6);
            z-index: 2;
        }

        .dialog-avatar canvas {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        /* å¯¹è¯æ¡†ä¸»ä½“ */
        .rpg-dialog-box {
            background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
            border: 4px solid #ffd700;
            margin-left: 80px;
            padding: 25px 25px 25px 30px;
            position: relative;
            box-shadow:
                0 0 0 4px #000,
                0 0 30px rgba(255, 215, 0, 0.4),
                inset 0 0 40px rgba(0, 0, 0, 0.5);
        }

        .rpg-dialog-box::before {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            background: linear-gradient(45deg, #ff6b6b, #ffd700, #4ecdc4, #a8e6cf);
            background-size: 300% 300%;
            z-index: -1;
            animation: dialogBorderGlow 4s ease infinite;
        }

        @keyframes dialogBorderGlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        /* å¯¹è¯æ¡†åç§° */
        .rpg-character-name {
            position: absolute;
            top: -20px;
            left: 20px;
            background: linear-gradient(90deg, #ffd700, #ff6b6b);
            color: #000;
            padding: 8px 20px;
            font-size: 12px;
            font-weight: bold;
            border: 3px solid #000;
            box-shadow: 3px 3px 0 #000;
            text-transform: uppercase;
            letter-spacing: 2px;
            image-rendering: pixelated;
        }

        /* å¯¹è¯æ–‡æœ¬åŒºåŸŸ */
        .rpg-dialog-text {
            color: #fff;
            font-size: 14px;
            line-height: 1.8;
            text-shadow: 2px 2px 0 #000;
            min-height: 80px;
            white-space: pre-wrap;
            position: relative;
            z-index: 1;
        }

        /* ç»§ç»­æç¤º */
        .dialog-continue-hint {
            position: absolute;
            bottom: 15px;
            right: 20px;
            color: #ffd700;
            font-size: 10px;
            animation: blink 1s ease-in-out infinite;
            text-shadow: 1px 1px 0 #000;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* å…³é—­æŒ‰é’® */
        .dialog-close-btn {
            position: absolute;
            top: -20px;
            right: -20px;
            background: #ff6b6b;
            color: #fff;
            border: 3px solid #000;
            padding: 10px 15px;
            font-size: 10px;
            cursor: pointer;
            font-family: 'Press Start 2P', monospace;
            box-shadow: 3px 3px 0 #000;
            transition: all 0.2s;
            image-rendering: pixelated;
            z-index: 3;
        }

        .dialog-close-btn:hover {
            background: #ff8888;
            transform: translate(-2px, -2px);
            box-shadow: 5px 5px 0 #000;
        }

        /* è§’è‰²æè¿° */
        .character-description {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 2px dashed #4ecdc4;
            font-size: 9px;
            color: #a8e6cf;
            line-height: 1.6;
        }

        .character-description strong {
            color: #ffd700;
        }

        /* åŠ è½½æŒ‡ç¤ºå™¨ */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffd700;
            font-size: 16px;
            text-align: center;
            z-index: 2000;
            text-shadow: 2px 2px 0 #ff0000;
        }

        .loading::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }

        /* ç‚¹å‡»æç¤º */
        .click-hint {
            position: fixed;
            bottom: 3%;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 8px;
            text-align: center;
            opacity: 0.7;
            animation: pulse 2s ease-in-out infinite;
            pointer-events: none;
            text-shadow: 1px 1px 0 #000;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* èƒŒæ™¯æ˜Ÿæ˜Ÿ */
        .star {
            position: fixed;
            width: 2px;
            height: 2px;
            background: #fff;
            animation: twinkle 3s ease-in-out infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        /* è§’è‰²åç§°æ ‡ç­¾ */
        .name-tag {
            position: fixed;
            display: none;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ffd700;
            color: #fff;
            padding: 4px 8px;
            font-size: 8px;
            pointer-events: none;
            z-index: 500;
            white-space: nowrap;
            image-rendering: pixelated;
        }

        /* æ§åˆ¶è¯´æ˜ */
        .controls-hint {
            position: fixed;
            bottom: 6%;
            left: 50%;
            transform: translateX(-50%);
            color: #888;
            font-size: 6px;
            text-align: center;
            opacity: 0.5;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div class="title-container">
        <div class="main-title">æé¢æ¡çš„åŠ¨ç‰©å›­</div>
        <div class="subtitle">âœ¨ MERRY CHRISTMAS! âœ¨</div>
    </div>

    <!-- RPG é£æ ¼å¯¹è¯æ¡†é®ç½©å±‚ -->
    <div class="rpg-overlay" id="rpg-overlay" onclick="closeRPGDialog(event)">
        <!-- å·¦ä¾§è§’è‰²ä¿¡æ¯å¡ç‰‡ -->
        <div class="character-info-card" id="character-info-card" onclick="event.stopPropagation()">
            <div class="info-card-title" id="info-name">è§’è‰²åç§°</div>
            <div class="info-card-stats">
                <div class="info-stat">
                    <span class="info-stat-label">ç±»å‹</span>
                    <span class="info-stat-value" id="info-type">çŒ«ç§‘</span>
                </div>
                <div class="info-stat">
                    <span class="info-stat-label">æ€§æ ¼</span>
                    <span class="info-stat-value" id="info-personality">æ¸©æŸ”</span>
                </div>
                <div class="info-stat">
                    <span class="info-stat-label">å¯çˆ±åº¦</span>
                    <span class="info-stat-value" id="info-cute">100%</span>
                </div>
                <div class="stat-bar">
                    <div class="stat-bar-fill" id="cute-bar" style="width: 100%"></div>
                </div>
                <div class="info-stat">
                    <span class="info-stat-label">æ´»åŠ›å€¼</span>
                    <span class="info-stat-value" id="info-energy">85%</span>
                </div>
                <div class="stat-bar">
                    <div class="stat-bar-fill" id="energy-bar" style="width: 85%"></div>
                </div>
            </div>
            <div class="character-description" id="info-description">
                <strong>è§’è‰²ä»‹ç»</strong><br>
                è¿™é‡Œæ˜¯è§’è‰²çš„è¯¦ç»†ä»‹ç»...
            </div>
        </div>

        <!-- ä¸»å¯¹è¯æ¡†å®¹å™¨ -->
        <div class="rpg-dialog-container" id="rpg-dialog-container" onclick="event.stopPropagation()">
            <button class="dialog-close-btn" onclick="closeRPGDialog(event)">âœ• å…³é—­</button>

            <!-- å¤´åƒåŒºåŸŸ -->
            <div class="dialog-avatar" id="dialog-avatar">
                <!-- Canvas ä¼šè¢« JS åŠ¨æ€æ’å…¥ -->
            </div>

            <!-- å¯¹è¯æ¡† -->
            <div class="rpg-dialog-box">
                <div class="rpg-character-name" id="rpg-character-name">è§’è‰²å</div>
                <div class="rpg-dialog-text" id="rpg-dialog-text"></div>
                <div class="dialog-continue-hint">â–¼ ç‚¹å‡»ç»§ç»­</div>
            </div>
        </div>
    </div>

    <div class="name-tag" id="name-tag"></div>

    <div class="click-hint">
        ğŸ„ ç‚¹å‡»è§’è‰²æŸ¥çœ‹ç¥ç¦ | ç§»åŠ¨é¼ æ ‡ä½“éªŒè§†å·®æ•ˆæœ ğŸ„
    </div>

    <div class="controls-hint">
        æ‹–æ‹½æ—‹è½¬è§†è§’ | æ»šè½®ç¼©æ”¾
    </div>

    <div class="loading" id="loading">åŠ è½½åƒç´ ä¸–ç•Œä¸­</div>

    <!-- åœ£è¯éŸ³ä¹ (8-bit Chiptune é£æ ¼) -->
    <audio id="christmas-music" loop preload="auto">
        <source src="https://assets.mixkit.co/music/preview/mixkit-christmas-gold-bells-573.mp3" type="audio/mpeg">
    </audio>

    <!-- éŸ³ä¹æ§åˆ¶æŒ‰é’® -->
    <button id="music-toggle" onclick="toggleMusic()" style="position: fixed; top: 20px; right: 20px; z-index: 100; background: rgba(255,215,0,0.9); border: 3px solid #000; padding: 10px 15px; font-family: 'Press Start 2P', monospace; font-size: 10px; cursor: pointer; image-rendering: pixelated; box-shadow: 3px 3px 0 #000;">
        ğŸµ éŸ³ä¹: OFF
    </button>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- GSAP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        // ==================== é…ç½® ====================
        const CONFIG = {
            colors: {
                sky: 0x0a0a1a,
                snow: 0xffffff,
                snowShadow: 0xcccccc,
                grass: 0x2d5a27,
                treeGreen: 0x1a4d1a,
                treeDark: 0x0f2f0f,
                trunkBrown: 0x4a3728,
                gold: 0xffd700,
                red: 0xff0000,
                green: 0x00ff00,
                blue: 0x0066ff,
                white: 0xffffff,
                black: 0x000000,
                houseWall: 0xf5deb3,
                houseRoof: 0x8b4513,
                houseWindow: 0xfffacd,
                giftRed: 0xff4444,
                giftBlue: 0x4444ff,
                giftGold: 0xffd700
            },
            characters: {
                miantiao: {
                    name: 'æé¢æ¡',
                    type: 'æ¾³æ´²çŸ­æ¯›çŒ«',
                    personality: 'å‚²å¨‡ç²˜äºº',
                    cute: 95,
                    energy: 60,
                    description: '<strong>æé¢æ¡</strong>æ˜¯ä¸€åªæ¾³æ´²çŸ­æ¯›çŒ«å¤§å“¥ï¼Œè™½ç„¶è„¾æ°”å¤æ€ªåƒä¸ªæ€ªè€å¤´ï¼Œä½†å†…å¿ƒæå…¶ç²˜äººã€‚æ¯å¤©æ™šä¸Šå¿…é¡»åœ¨ä¸»äººæ€€é‡Œæ‰èƒ½å…¥ç¡ï¼Œæ˜¯å®éªŒå®¤é‡Œæœ€æœ‰å®‰å…¨æ„Ÿçš„å­˜åœ¨ã€‚çœ‹ä¼¼é«˜å†·ï¼Œå®åˆ™æ˜¯ä¸ªè¶…çº§ç²˜äººçš„å°å¯çˆ±ï¼',
                    color: 0x666666,
                    secondaryColor: 0x888888,
                    position: { x: 0, y: 1, z: 8 },
                    scale: 1.2,
                    orbitRadius: 6,
                    orbitSpeed: 0.3,
                    orbitOffset: 0,
                    message: 'ï¼ˆæå…¶ç²˜äººåœ°å‡‘è¿‘ï¼‰\n\nåœ£è¯å¿«ä¹â€¦â€¦\næ™šä¸Šäº†ï¼Œè¯¥ç¡è§‰äº†ï¼Œ\nå¿«æŠŠæ€€é‡Œè…¾å‡ºæ¥ç»™æˆ‘ã€‚\n\nâ€”â€”æé¢æ¡'
                },
                doubao: {
                    name: 'ç”°è±†åŒ…',
                    type: 'é“¶æ¸å±‚çŒ«å’ª',
                    personality: 'è¶…çº§æ¸©æŸ”',
                    cute: 100,
                    energy: 75,
                    description: '<strong>ç”°è±†åŒ…</strong>æ˜¯ä¸€åªèƒ–ä¹ä¹å¯çˆ±çš„é“¶æ¸å±‚ï¼Œè„¾æ°”æå¥½ï¼Œéšä¾¿æ€ä¹ˆç©éƒ½ä¸ä¼šç”Ÿæ°”ã€‚åœ†æ¶¦çš„èº«æå’Œæ¸©æŸ”çš„æ€§æ ¼è®©ä»–æˆä¸ºå®éªŒå®¤é‡Œçš„è§£å‹ç¥å™¨ã€‚ä»æ¥ä¸ç”Ÿæ°”æ˜¯ä»–çš„è¶…èƒ½åŠ›ï¼Œè¢«æ‰æˆå›¢ä¹Ÿåªä¼šå–µå–µå«ï¼',
                    color: 0xb0b0b0,
                    secondaryColor: 0xd0d0d0,
                    position: { x: 5, y: 1, z: 6 },
                    scale: 1.3,
                    orbitRadius: 7,
                    orbitSpeed: 0.5,
                    orbitOffset: Math.PI / 2,
                    message: 'ï¼ˆè¢«äººæ‰ææˆä¸€å›¢ï¼‰\n\nå–µï¼å–µï¼å–µï¼\nåœ£è¯å¿«ä¹ï¼\nçœ‹åˆ°ä½ çœŸé«˜å…´ï¼Œ\nå¿«æ¥æ‰æˆ‘ï¼\n\nâ€”â€”ç”°è±†åŒ…'
                },
                huajuan: {
                    name: 'æèŠ±å·',
                    type: 'å¸ƒå¶çŒ«',
                    personality: 'ä¼˜é›…æ·‘å¥³',
                    cute: 98,
                    energy: 55,
                    description: '<strong>æèŠ±å·</strong>æ˜¯ä¸€åªæ¼‚æ¼‚äº®äº®çš„å¸ƒå¶çŒ«ï¼Œä¸€ä¸¾ä¸€åŠ¨éƒ½é€éœ²ç€ä¼˜é›…å’Œæ·‘å¥³æ°”è´¨ã€‚è„¾æ°”æå¥½ä»æ¥ä¸å“ˆæ°”ï¼Œä½†æ€»è¢«å°ç‹—æ¬ºè´Ÿï¼Œæ˜¯å®éªŒå®¤é‡Œæœ€æ¸©æŸ”çš„å§å§ã€‚å¦‚åŒå¥¹çš„åå­—ä¸€æ ·ï¼ŒåƒèŠ±å·ä¸€æ ·ç¾ä¸½åŠ¨äººã€‚',
                    color: 0xd0c0d8,
                    secondaryColor: 0xe8d8f0,
                    position: { x: -5, y: 1, z: 6 },
                    scale: 1.1,
                    orbitRadius: 8,
                    orbitSpeed: 0.25,
                    orbitOffset: Math.PI,
                    message: 'ï¼ˆæ¸©æŸ”åœ°è¡Œç¤¼ï¼‰\n\nåœ£è¯å¿«ä¹ï¼Œ\nåœ¨è¿™ç¾å¥½çš„èŠ‚æ—¥é‡Œï¼Œ\nç¥ä½ ä¹Ÿè¢«æ¸©æŸ”ä»¥å¾…ã€‚\n\nâ€”â€”æèŠ±å·'
                },
                wantou: {
                    name: 'ç”°çªå¤´',
                    type: 'æŸ¯åŸºå¦¹å¦¹',
                    personality: 'æ´»åŠ›æ»¡æ»¡',
                    cute: 100,
                    energy: 100,
                    description: '<strong>ç”°çªå¤´</strong>æ˜¯ä¸€åªå¯å¯çˆ±çˆ±çš„æŸ¯åŸºå¦¹å¦¹ï¼Œæ€§æ ¼å®Œç¾ï¼Œå–œæ¬¢ç©è€ã€‚å°çŸ­è…¿å¤§èƒ½é‡ï¼Œæ˜¯å®éªŒå®¤é‡Œçš„å¼€å¿ƒæœï¼Œæ°¸è¿œå……æ»¡æ´»åŠ›å’Œå¥½å¥‡å¿ƒã€‚è™½ç„¶è…¿çŸ­ä½†è·‘å¾—é£å¿«ï¼Œæ¯å¤©éƒ½åœ¨ç”¨æ— é™çš„çƒ­æƒ…æ„ŸæŸ“ç€å¤§å®¶ï¼',
                    color: 0xc4a882,
                    secondaryColor: 0xd8bc96,
                    position: { x: 0, y: 1, z: 9 },
                    scale: 0.9,
                    orbitRadius: 6.5,
                    orbitSpeed: 0.7,
                    orbitOffset: Math.PI * 1.5,
                    message: 'ï¼ˆç–¯ç‹‚æ‘‡å°¾å·´å†²è¿‡æ¥ï¼‰\n\nå˜¿ï¼æ¥ç©å•Šï¼æ¥ç©å•Šï¼\nåœ£è¯èŠ‚å°±æ˜¯è¦ä¸€èµ·ç–¯ï¼\nèŠ±å·å§å§æˆ‘ä»¬æ¥ç€è·‘ï¼\n\nâ€”â€”ç”°çªå¤´'
                }
            }
        };

        // ==================== å…¨å±€å˜é‡ ====================
        let scene, camera, renderer;
        let island, characters = [], characterMeshes = [];
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let clock = new THREE.Clock();
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let snowflakes = [];
        let nameTag = document.getElementById('name-tag');

        // ==================== å·¥å…·å‡½æ•°ï¼šåˆ›å»ºåƒç´ çº¹ç† ====================
        function createPixelTexture(color, size = 8, pixelSize = 2) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // å°†é¢œè‰²è½¬æ¢ä¸º RGB
            const r = (color >> 16) & 255;
            const g = (color >> 8) & 255;
            const b = color & 255;

            // åˆ›å»ºåƒç´ å—å›¾æ¡ˆ
            const blockSize = size / pixelSize;
            for (let x = 0; x < pixelSize; x++) {
                for (let y = 0; y < pixelSize; y++) {
                    // æ·»åŠ è½»å¾®çš„é¢œè‰²å˜åŒ–
                    const variation = (Math.random() - 0.5) * 20;
                    const brightness = 0.9 + Math.random() * 0.2;

                    ctx.fillStyle = `rgb(${Math.min(255, Math.max(0, r * brightness + variation))}, ${Math.min(255, Math.max(0, g * brightness + variation))}, ${Math.min(255, Math.max(0, b * brightness + variation))})`;
                    ctx.fillRect(x * blockSize, y * blockSize, blockSize, blockSize);
                }
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        // ==================== å·¥å…·å‡½æ•°ï¼šåˆ›å»ºåƒç´ ç›’å­ ====================
        function createPixelBox(width, height, depth, color, castShadow = true) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const texture = createPixelTexture(color);
            const material = new THREE.MeshLambertMaterial({
                map: texture,
                color: color
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = castShadow;
            mesh.receiveShadow = true;
            return mesh;
        }

        // ==================== åˆ›å»ºæµ®ç©ºå²›å±¿ ====================
        function createIsland() {
            const islandGroup = new THREE.Group();

            // ä¸»å¹³å° - åˆ†å±‚åˆ›å»ºåƒç´ æ•ˆæœ
            const layers = [
                { y: -3, size: 22, color: CONFIG.colors.grass, height: 2 },
                { y: -1.5, size: 20, color: CONFIG.colors.grass, height: 1.5 },
                { y: -0.5, size: 18, color: 0x3d6a37, height: 1 },
                { y: 0.2, size: 16, color: CONFIG.colors.snow, height: 0.4 }
            ];

            layers.forEach(layer => {
                const platform = createPixelBox(layer.size, layer.height, layer.size, layer.color);
                platform.position.y = layer.y;
                islandGroup.add(platform);
            });

            // æ·»åŠ æ …æ å’Œå½©ç¯
            const fencePositions = [];
            const perimeter = 7;
            for (let i = -perimeter; i <= perimeter; i += 2) {
                fencePositions.push({ x: i, z: perimeter });
                fencePositions.push({ x: i, z: -perimeter });
                fencePositions.push({ x: perimeter, z: i });
                fencePositions.push({ x: -perimeter, z: i });
            }

            fencePositions.forEach(pos => {
                // æ …æ æŸ±
                const fencePost = createPixelBox(0.6, 1.8, 0.6, CONFIG.colors.trunkBrown);
                fencePost.position.set(pos.x, 1.1, pos.z);
                islandGroup.add(fencePost);

                // å½©ç¯
                const lightColor = [CONFIG.colors.red, CONFIG.colors.green, CONFIG.colors.gold, CONFIG.colors.blue][Math.floor(Math.random() * 4)];
                const light = new THREE.PointLight(lightColor, 0.3, 4);
                light.position.set(pos.x, 2, pos.z);
                islandGroup.add(light);

                const lightBulb = createPixelBox(0.25, 0.25, 0.25, lightColor);
                lightBulb.position.set(pos.x, 2, pos.z);
                lightBulb.material = new THREE.MeshBasicMaterial({ color: lightColor });
                islandGroup.add(lightBulb);

                // é—ªçƒåŠ¨ç”»
                gsap.to(lightBulb.material, {
                    opacity: 0.3,
                    duration: 0.3 + Math.random() * 0.7,
                    repeat: -1,
                    yoyo: true
                });

                gsap.to(light, {
                    intensity: 0.1,
                    duration: 0.3 + Math.random() * 0.7,
                    repeat: -1,
                    yoyo: true
                });
            });

            return islandGroup;
        }

        // ==================== åˆ›å»ºæˆ¿å­ ====================
        function createHouse() {
            const houseGroup = new THREE.Group();

            // ä¸»ä½“
            const walls = createPixelBox(8, 6, 6, CONFIG.colors.houseWall);
            walls.position.y = 3;
            houseGroup.add(walls);

            // å±‹é¡¶ - åˆ†å±‚
            const roofLayers = [
                { y: 6.5, sizeX: 9, sizeZ: 7 },
                { y: 7.5, sizeX: 7, sizeZ: 5 }
            ];

            roofLayers.forEach(layer => {
                const roof = createPixelBox(layer.sizeX, 1.5, layer.sizeZ, CONFIG.colors.houseRoof);
                roof.position.y = layer.y;
                houseGroup.add(roof);
            });

            // çƒŸå›±
            const chimney = createPixelBox(1.5, 3, 1.5, CONFIG.colors.trunkBrown);
            chimney.position.set(2.5, 8.5, 2);
            houseGroup.add(chimney);

            // çƒŸå›±é¡¶éƒ¨
            const chimneyTop = createPixelBox(1.8, 0.5, 1.8, CONFIG.colors.red);
            chimneyTop.position.set(2.5, 10, 2);
            houseGroup.add(chimneyTop);

            // çª—æˆ·
            const windowPositions = [
                { x: -2.5, y: 4, z: 3.1 },
                { x: 2.5, y: 4, z: 3.1 },
                { x: 0, y: 4, z: -3.1 }
            ];

            windowPositions.forEach(pos => {
                const windowFrame = createPixelBox(2, 2, 0.2, CONFIG.colors.trunkBrown);
                windowFrame.position.set(pos.x, pos.y, pos.z);
                houseGroup.add(windowFrame);

                const windowGlass = createPixelBox(1.6, 1.6, 0.1, CONFIG.colors.houseWindow);
                windowGlass.position.set(pos.x, pos.y, pos.z + 0.15);
                windowGlass.material = new THREE.MeshBasicMaterial({
                    color: CONFIG.colors.gold,
                    transparent: true,
                    opacity: 0.8
                });
                houseGroup.add(windowGlass);

                // çª—æˆ·å‘å…‰
                const windowLight = new THREE.PointLight(CONFIG.colors.gold, 0.5, 5);
                windowLight.position.set(pos.x, pos.y, pos.z + 1);
                houseGroup.add(windowLight);
            });

            // é—¨
            const door = createPixelBox(2.5, 4, 0.3, CONFIG.colors.trunkBrown);
            door.position.set(0, 2, 3.2);
            houseGroup.add(door);

            // é—¨æŠŠæ‰‹
            const doorKnob = createPixelBox(0.2, 0.2, 0.2, CONFIG.colors.gold);
            doorKnob.position.set(0.8, 2, 3.4);
            houseGroup.add(doorKnob);

            // éœ“è™¹ç¯æ‹›ç‰Œåº•åº§
            const signBase = createPixelBox(12, 0.5, 2, 0x222222);
            signBase.position.set(0, 8.5, 0);
            houseGroup.add(signBase);

            // å‘å…‰é¢æ¿
            const signPanel = createPixelBox(11.5, 0.3, 1.5, 0x111111);
            signPanel.position.set(0, 8.8, 0);
            signPanel.material = new THREE.MeshBasicMaterial({ color: 0x111111 });
            houseGroup.add(signPanel);

            // æ‹›ç‰Œç¯å…‰
            const signLight1 = new THREE.PointLight(CONFIG.colors.gold, 1, 10);
            signLight1.position.set(-3, 9, 2);
            houseGroup.add(signLight1);

            const signLight2 = new THREE.PointLight(CONFIG.colors.red, 0.8, 8);
            signLight2.position.set(3, 9, 2);
            houseGroup.add(signLight2);

            // çƒŸé›¾ç²’å­
            for (let i = 0; i < 6; i++) {
                const smokeSize = 0.3 + Math.random() * 0.2;
                const smoke = new THREE.Mesh(
                    new THREE.BoxGeometry(smokeSize, smokeSize, smokeSize),
                    new THREE.MeshBasicMaterial({
                        color: 0xcccccc,
                        transparent: true,
                        opacity: 0.4
                    })
                );
                smoke.position.set(2.5, 10 + i * 0.6, 2);
                houseGroup.add(smoke);

                // çƒŸé›¾ä¸Šå‡åŠ¨ç”»
                gsap.to(smoke.position, {
                    y: smoke.position.y + 4,
                    duration: 4 + i * 0.5,
                    repeat: -1,
                    ease: "none"
                });

                gsap.to(smoke.material, {
                    opacity: 0,
                    duration: 4 + i * 0.5,
                    repeat: -1,
                    ease: "none"
                });

                gsap.to(smoke.scale, {
                    x: 2,
                    y: 2,
                    z: 2,
                    duration: 4 + i * 0.5,
                    repeat: -1,
                    ease: "none"
                });
            }

            return houseGroup;
        }

        // ==================== åˆ›å»ºåœ£è¯æ ‘ ====================
        function createChristmasTree(x, y, z, scale = 1) {
            const treeGroup = new THREE.Group();

            // æ ‘å¹²
            const trunk = createPixelBox(1 * scale, 2 * scale, 1 * scale, CONFIG.colors.trunkBrown);
            trunk.position.y = 1 * scale;
            treeGroup.add(trunk);

            // æ ‘å†  - å¤šå±‚
            const layerConfigs = [
                { width: 5, height: 2, y: 2.5 },
                { width: 4, height: 2, y: 4.5 },
                { width: 3, height: 1.5, y: 6.5 },
                { width: 2, height: 1.5, y: 8 }
            ];

            layerConfigs.forEach((config, index) => {
                const layer = createPixelBox(
                    config.width * scale,
                    config.height * scale,
                    config.width * scale,
                    index % 2 === 0 ? CONFIG.colors.treeGreen : CONFIG.colors.treeDark
                );
                layer.position.y = config.y * scale;
                treeGroup.add(layer);

                // æ·»åŠ è£…é¥°å½©ç¯
                const ornamentCount = 6 + index * 2;
                for (let i = 0; i < ornamentCount; i++) {
                    const angle = (i / ornamentCount) * Math.PI * 2;
                    const radius = (config.width * scale * 0.35);
                    const ox = Math.cos(angle) * radius;
                    const oz = Math.sin(angle) * radius;
                    const oy = config.y * scale + (Math.random() - 0.5) * config.height * scale * 0.8;

                    const ornamentColor = [CONFIG.colors.red, CONFIG.colors.gold, CONFIG.colors.blue, CONFIG.colors.white][Math.floor(Math.random() * 4)];
                    const ornament = createPixelBox(0.35 * scale, 0.35 * scale, 0.35 * scale, ornamentColor, false);
                    ornament.position.set(ox, oy, oz);
                    ornament.material = new THREE.MeshBasicMaterial({ color: ornamentColor });
                    treeGroup.add(ornament);

                    // é—ªçƒåŠ¨ç”»
                    gsap.to(ornament.material, {
                        opacity: 0.3,
                        duration: 0.2 + Math.random() * 0.6,
                        repeat: -1,
                        yoyo: true,
                        delay: Math.random() * 2
                    });

                    // æ·»åŠ ç‚¹å…‰æº
                    const ornamentLight = new THREE.PointLight(ornamentColor, 0.3, 2);
                    ornamentLight.position.set(ox, oy, oz);
                    treeGroup.add(ornamentLight);
                }
            });

            // æ ‘é¡¶æ˜Ÿæ˜Ÿ
            const starSize = 0.8 * scale;
            const star = new THREE.Mesh(
                new THREE.BoxGeometry(starSize, starSize, starSize),
                new THREE.MeshBasicMaterial({ color: CONFIG.colors.gold })
            );
            star.position.y = 9.5 * scale;
            treeGroup.add(star);

            // æ˜Ÿæ˜Ÿå‘å…‰
            const starLight = new THREE.PointLight(CONFIG.colors.gold, 1.5, 6);
            starLight.position.y = 9.5 * scale;
            treeGroup.add(starLight);

            // æ˜Ÿæ˜Ÿé—ªçƒ
            gsap.to(star.material, {
                opacity: 0.6,
                duration: 0.8,
                repeat: -1,
                yoyo: true
            });

            gsap.to(starLight, {
                intensity: 0.8,
                duration: 0.8,
                repeat: -1,
                yoyo: true
            });

            // æ ‘åº•ç¤¼ç‰©
            const giftCount = 2 + Math.floor(Math.random() * 3);
            for (let i = 0; i < giftCount; i++) {
                const giftSize = 0.4 + Math.random() * 0.3;
                const giftAngle = (i / giftCount) * Math.PI * 2;
                const giftRadius = 2.5 * scale + Math.random() * 1;
                const gift = createPixelGift(
                    (Math.cos(giftAngle) * giftRadius),
                    0,
                    (Math.sin(giftAngle) * giftRadius),
                    giftSize
                );
                treeGroup.add(gift);
            }

            treeGroup.position.set(x, y, z);
            return treeGroup;
        }

        // ==================== åˆ›å»ºç¤¼ç‰©ç›’ ====================
        function createPixelGift(x, y, z, size = 0.6) {
            const giftGroup = new THREE.Group();

            const boxColor = [CONFIG.colors.giftRed, CONFIG.colors.giftBlue, CONFIG.colors.gold][Math.floor(Math.random() * 3)];
            const box = createPixelBox(size, size, size, boxColor);
            box.position.y = size / 2;
            giftGroup.add(box);

            // ä¸å¸¦
            const ribbonV = createPixelBox(size * 0.25, size, size * 0.25, CONFIG.colors.gold);
            ribbonV.position.set(0, size / 2, 0);
            giftGroup.add(ribbonV);

            const ribbonH = createPixelBox(size, size * 0.25, size * 0.25, CONFIG.colors.gold);
            ribbonH.position.set(0, size / 2, 0);
            giftGroup.add(ribbonH);

            // è´è¶ç»“
            const bow = createPixelBox(size * 0.5, size * 0.3, size * 0.5, CONFIG.colors.gold);
            bow.position.set(0, size + 0.15, 0);
            giftGroup.add(bow);

            giftGroup.position.set(x, y, z);

            // å¾…æœºåŠ¨ç”»
            gsap.to(giftGroup.position, {
                y: y + 0.1,
                duration: 1.2 + Math.random() * 0.5,
                repeat: -1,
                yoyo: true,
                ease: "sine.inOut"
            });

            return giftGroup;
        }

        // ==================== åˆ›å»ºåƒç´ è§’è‰²ï¼ˆä½¿ç”¨ Canvas ç»˜åˆ¶å¯çˆ±åŠ¨ç‰©ï¼‰ ====================
        function createCharacter(config) {
            const characterGroup = new THREE.Group();
            const scale = config.scale || 1;
            const canvasSize = 128;
            const canvas = document.createElement('canvas');
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            const ctx = canvas.getContext('2d');

            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvasSize, canvasSize);

            // è®¾ç½®åƒç´ é£æ ¼
            ctx.imageSmoothingEnabled = false;

            // ç»˜åˆ¶å¯çˆ±çš„åƒç´ åŠ¨ç‰©
            const centerX = canvasSize / 2;
            const centerY = canvasSize / 2;
            const pixelSize = 4;

            // æ ¹æ®è§’è‰²ç±»å‹ç»˜åˆ¶
            if (config.name === 'ç”°çªå¤´') {
                // æŸ¯åŸºå°ç‹—
                // èº«ä½“ (æ£•è‰²æ¤­åœ†)
                ctx.fillStyle = '#c4a882';
                for (let i = 0; i < 200; i++) {
                    const x = centerX + (Math.random() - 0.5) * 60;
                    const y = centerY + 15 + (Math.random() - 0.5) * 35;
                    const size = pixelSize + Math.random() * pixelSize;
                    ctx.fillRect(Math.floor(x / pixelSize) * pixelSize, Math.floor(y / pixelSize) * pixelSize, size, size);
                }

                // å¤´ (åœ†)
                ctx.fillStyle = '#d8bc96';
                for (let i = 0; i < 150; i++) {
                    const x = centerX + (Math.random() - 0.5) * 50;
                    const y = centerY - 15 + (Math.random() - 0.5) * 45;
                    const size = pixelSize + Math.random() * pixelSize;
                    ctx.fillRect(Math.floor(x / pixelSize) * pixelSize, Math.floor(y / pixelSize) * pixelSize, size, size);
                }

                // å¤§è€³æœµ
                ctx.fillStyle = '#c4a882';
                // å·¦è€³
                for (let i = 0; i < 40; i++) {
                    const x = centerX - 30 + (Math.random() - 0.5) * 20;
                    const y = centerY - 40 + (Math.random() - 0.5) * 25;
                    ctx.fillRect(Math.floor(x / pixelSize) * pixelSize, Math.floor(y / pixelSize) * pixelSize, pixelSize * 2, pixelSize * 2);
                }
                // å³è€³
                for (let i = 0; i < 40; i++) {
                    const x = centerX + 30 + (Math.random() - 0.5) * 20;
                    const y = centerY - 40 + (Math.random() - 0.5) * 25;
                    ctx.fillRect(Math.floor(x / pixelSize) * pixelSize, Math.floor(y / pixelSize) * pixelSize, pixelSize * 2, pixelSize * 2);
                }

                // çœ¼ç› (å¤§è€Œåœ†)
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(centerX - 12, centerY - 20, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(centerX + 12, centerY - 20, 8, 0, Math.PI * 2);
                ctx.fill();

                // çœ¼ç›é«˜å…‰
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(centerX - 14, centerY - 22, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(centerX + 10, centerY - 22, 3, 0, Math.PI * 2);
                ctx.fill();

                // é¼»å­ (é»‘è‰²åœ†å½¢)
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(centerX, centerY - 5, 5, 0, Math.PI * 2);
                ctx.fill();

                // å˜´å·´ (Wå½¢)
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centerX - 6, centerY, 5, 0, Math.PI);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(centerX + 6, centerY, 5, 0, Math.PI);
                ctx.stroke();

                // èˆŒå¤´ (ç²‰è‰²)
                ctx.fillStyle = '#ff9999';
                ctx.beginPath();
                ctx.ellipse(centerX, centerY + 8, 6, 8, 0, 0, Math.PI * 2);
                ctx.fill();

            } else {
                // çŒ«å’ª (å…¶ä»–ä¸‰åª)
                // èº«ä½“ (åœ†æ¶¦)
                ctx.fillStyle = config.name === 'ç”°è±†åŒ…' ? '#d0d0d0' : (config.name === 'æèŠ±å·' ? '#e8d8f0' : '#888888');
                for (let i = 0; i < 180; i++) {
                    const x = centerX + (Math.random() - 0.5) * 55;
                    const y = centerY + 20 + (Math.random() - 0.5) * 30;
                    const size = pixelSize + Math.random() * pixelSize;
                    ctx.fillRect(Math.floor(x / pixelSize) * pixelSize, Math.floor(y / pixelSize) * pixelSize, size, size);
                }

                // å¤´ (æ›´åœ†æ›´å¤§)
                ctx.fillStyle = config.name === 'ç”°è±†åŒ…' ? '#e0e0e0' : (config.name === 'æèŠ±å·' ? '#f0e8f8' : '#999999');
                for (let i = 0; i < 160; i++) {
                    const x = centerX + (Math.random() - 0.5) * 55;
                    const y = centerY - 10 + (Math.random() - 0.5) * 50;
                    const size = pixelSize + Math.random() * pixelSize;
                    ctx.fillRect(Math.floor(x / pixelSize) * pixelSize, Math.floor(y / pixelSize) * pixelSize, size, size);
                }

                // ä¸‰è§’å½¢è€³æœµ
                ctx.fillStyle = config.name === 'ç”°è±†åŒ…' ? '#d0d0d0' : (config.name === 'æèŠ±å·' ? '#e8d8f0' : '#888888');
                // å·¦è€³
                ctx.beginPath();
                ctx.moveTo(centerX - 35, centerY - 30);
                ctx.lineTo(centerX - 25, centerY - 60);
                ctx.lineTo(centerX - 10, centerY - 35);
                ctx.fill();
                // å³è€³
                ctx.beginPath();
                ctx.moveTo(centerX + 35, centerY - 30);
                ctx.lineTo(centerX + 25, centerY - 60);
                ctx.lineTo(centerX + 10, centerY - 35);
                ctx.fill();

                // å†…è€³ (ç²‰è‰²)
                ctx.fillStyle = '#ffb6c1';
                ctx.beginPath();
                ctx.moveTo(centerX - 32, centerY - 32);
                ctx.lineTo(centerX - 25, centerY - 52);
                ctx.lineTo(centerX - 15, centerY - 35);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(centerX + 32, centerY - 32);
                ctx.lineTo(centerX + 25, centerY - 52);
                ctx.lineTo(centerX + 15, centerY - 35);
                ctx.fill();

                // çœ¼ç› (å¤§è€Œåœ†çš„çŒ«çœ¼)
                ctx.fillStyle = '#2c5aa0';
                ctx.beginPath();
                ctx.ellipse(centerX - 12, centerY - 15, 7, 9, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(centerX + 12, centerY - 15, 7, 9, 0, 0, Math.PI * 2);
                ctx.fill();

                // ç³å­”
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.ellipse(centerX - 12, centerY - 15, 3, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(centerX + 12, centerY - 15, 3, 6, 0, 0, Math.PI * 2);
                ctx.fill();

                // çœ¼ç›é«˜å…‰
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(centerX - 14, centerY - 17, 2.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(centerX + 10, centerY - 17, 2.5, 0, Math.PI * 2);
                ctx.fill();

                // å°é¼»å­
                ctx.fillStyle = '#ffb6c1';
                ctx.beginPath();
                ctx.moveTo(centerX, centerY - 2);
                ctx.lineTo(centerX - 4, centerY + 3);
                ctx.lineTo(centerX + 4, centerY + 3);
                ctx.fill();

                // å˜´å·´
                ctx.strokeStyle = '#666666';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY + 3);
                ctx.lineTo(centerX, centerY + 10);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(centerX - 6, centerY + 10, 6, 0, Math.PI);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(centerX + 6, centerY + 10, 6, 0, Math.PI);
                ctx.stroke();

                // èƒ¡é¡»
                ctx.strokeStyle = '#888888';
                ctx.lineWidth = 1.5;
                // å·¦ä¾§èƒ¡é¡»
                ctx.beginPath();
                ctx.moveTo(centerX - 25, centerY);
                ctx.lineTo(centerX - 45, centerY - 5);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(centerX - 25, centerY + 5);
                ctx.lineTo(centerX - 45, centerY + 5);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(centerX - 25, centerY + 10);
                ctx.lineTo(centerX - 45, centerY + 15);
                ctx.stroke();
                // å³ä¾§èƒ¡é¡»
                ctx.beginPath();
                ctx.moveTo(centerX + 25, centerY);
                ctx.lineTo(centerX + 45, centerY - 5);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(centerX + 25, centerY + 5);
                ctx.lineTo(centerX + 45, centerY + 5);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(centerX + 25, centerY + 10);
                ctx.lineTo(centerX + 45, centerY + 15);
                ctx.stroke();
            }

            // åˆ›å»ºçº¹ç†
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;

            // åˆ›å»ºå¹³é¢æ˜¾ç¤ºè§’è‰²
            const geometry = new THREE.PlaneGeometry(3 * scale, 3 * scale);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });
            const sprite = new THREE.Mesh(geometry, material);

            // è®©è§’è‰²å§‹ç»ˆé¢å‘ç›¸æœº
            sprite.position.y = 1.5 * scale;

            characterGroup.add(sprite);

            characterGroup.position.set(config.position.x, config.position.y, config.position.z);
            characterGroup.userData = config;

            return characterGroup;
        }

        // ==================== æ·»åŠ è§’è‰²å¾…æœºåŠ¨ç”» ====================
        function addIdleAnimation(character, name) {
            // ç°åœ¨åŠ¨ç‰©ä»¬åœ¨è·‘åŠ¨ï¼Œæ·»åŠ è½»å¾®çš„ä¸Šä¸‹è·³åŠ¨æ•ˆæœ
            const bounceSpeed = 2 + Math.random();
            const bounceHeight = 0.1 + Math.random() * 0.1;

            gsap.to(character.position, {
                y: character.position.y + bounceHeight,
                duration: bounceSpeed,
                repeat: -1,
                yoyo: true,
                ease: "sine.inOut"
            });
        }

        // ==================== åˆ›å»ºé›ªèŠ±ç²’å­ ====================
        function createSnowflakes(count = 300) {
            const snowflakes = [];

            for (let i = 0; i < count; i++) {
                const snowSize = 0.08 + Math.random() * 0.1;
                const snowGeometry = new THREE.BoxGeometry(snowSize, snowSize, snowSize);
                const snowMaterial = new THREE.MeshBasicMaterial({
                    color: CONFIG.colors.white,
                    transparent: true,
                    opacity: 0.6 + Math.random() * 0.4
                });

                const snowflake = new THREE.Mesh(snowGeometry, snowMaterial);

                snowflake.position.set(
                    (Math.random() - 0.5) * 60,
                    Math.random() * 40 + 10,
                    (Math.random() - 0.5) * 60
                );

                snowflake.userData = {
                    fallSpeed: 0.015 + Math.random() * 0.04,
                    swaySpeed: 0.3 + Math.random() * 0.5,
                    swayAmount: 0.3 + Math.random() * 0.8,
                    offset: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.05
                };

                scene.add(snowflake);
                snowflakes.push(snowflake);
            }

            return snowflakes;
        }

        // ==================== æ›´æ–°é›ªèŠ± ====================
        function updateSnowflakes(snowflakes, time) {
            snowflakes.forEach(snowflake => {
                // ä¸‹è½
                snowflake.position.y -= snowflake.userData.fallSpeed;

                // å·¦å³é£˜åŠ¨
                snowflake.position.x += Math.sin(time * snowflake.userData.swaySpeed + snowflake.userData.offset) * 0.008;

                // æ—‹è½¬
                snowflake.rotation.x += snowflake.userData.rotationSpeed;
                snowflake.rotation.y += snowflake.userData.rotationSpeed * 0.5;

                // å¾ªç¯
                if (snowflake.position.y < -8) {
                    snowflake.position.y = 45;
                    snowflake.position.x = (Math.random() - 0.5) * 60;
                    snowflake.position.z = (Math.random() - 0.5) * 60;
                }
            });
        }

        // ==================== åˆå§‹åŒ–åœºæ™¯ ====================
        function init() {
            // åœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.sky);
            scene.fog = new THREE.Fog(CONFIG.colors.sky, 25, 60);

            // ç›¸æœº (ç­‰è½´æµ‹è§†è§’)
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(40, aspect, 0.1, 1000);

            // ç­‰è½´æµ‹ç›¸æœºä½ç½®
            const isoDistance = 35;
            const isoAngle = Math.atan(1 / Math.sqrt(2));
            camera.position.set(
                isoDistance * Math.cos(isoAngle),
                isoDistance * Math.sin(isoAngle) * 0.8,
                isoDistance * Math.sin(isoAngle)
            );
            camera.lookAt(0, 3, 0);

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.35);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(15, 25, 15);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 100;
            directionalLight.shadow.camera.left = -30;
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;
            scene.add(directionalLight);

            // æ·»åŠ é¢å¤–çš„ç¯å¢ƒå…‰
            const fillLight = new THREE.DirectionalLight(0x6688cc, 0.2);
            fillLight.position.set(-10, 10, -10);
            scene.add(fillLight);

            // åˆ›å»ºåœºæ™¯å…ƒç´ 
            island = createIsland();
            scene.add(island);

            // æ·»åŠ æˆ¿å­
            const house = createHouse();
            house.position.set(0, 0, 0);
            island.add(house);

            // æ·»åŠ å¤§åœ£è¯æ ‘ï¼ˆä¸­å¿ƒï¼‰
            const mainTree = createChristmasTree(-4, 0, 2, 1.5);
            island.add(mainTree);

            // æ·»åŠ å°åœ£è¯æ ‘
            const tree2 = createChristmasTree(5, 0, -3, 0.9);
            island.add(tree2);

            const tree3 = createChristmasTree(-6, 0, -4, 0.7);
            island.add(tree3);

            const tree4 = createChristmasTree(6, 0, 3, 0.6);
            island.add(tree4);

            // æ·»åŠ æ•£è½çš„ç¤¼ç‰©
            const giftPositions = [
                { x: 2, y: 0.3, z: 5 },
                { x: -1, y: 0.3, z: 6 },
                { x: 6, y: 0.3, z: 1 },
                { x: -7, y: 0.3, z: 1 },
                { x: 5, y: 0.3, z: -5 },
                { x: -5, y: 0.3, z: -6 },
                { x: 0, y: 0.3, z: -6 },
                { x: 7, y: 0.3, z: -1 }
            ];

            giftPositions.forEach(pos => {
                const gift = createPixelGift(pos.x, pos.y, pos.z, 0.4 + Math.random() * 0.4);
                island.add(gift);
            });

            // æ·»åŠ è§’è‰²
            Object.values(CONFIG.characters).forEach(charConfig => {
                const character = createCharacter(charConfig);
                island.add(character);
                characters.push(character);

                // æ”¶é›†è§’è‰²ç½‘æ ¼ç”¨äºç‚¹å‡»æ£€æµ‹
                character.traverse((child) => {
                    if (child.isMesh) {
                        child.userData.character = character;
                        characterMeshes.push(child);
                    }
                });

                // æ·»åŠ å¾…æœºåŠ¨ç”»
                addIdleAnimation(character, charConfig.name);
            });

            // æ·»åŠ é›ªèŠ±
            snowflakes = createSnowflakes();

            // æ·»åŠ èƒŒæ™¯æ˜Ÿæ˜Ÿ
            createBackgroundStars();

            // äº‹ä»¶ç›‘å¬
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('click', onMouseClick);
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mouseup', onMouseUp);
            window.addEventListener('wheel', onMouseWheel);

            // éšè—åŠ è½½æç¤º
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
            }, 1200);
        }

        // ==================== åˆ›å»ºèƒŒæ™¯æ˜Ÿæ˜Ÿ ====================
        function createBackgroundStars() {
            for (let i = 0; i < 150; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 70 + '%';
                star.style.animationDelay = Math.random() * 3 + 's';
                star.style.opacity = Math.random() * 0.5 + 0.3;
                document.body.appendChild(star);
            }
        }

        // ==================== çª—å£è°ƒæ•´ ====================
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ==================== é¼ æ ‡ç§»åŠ¨ ====================
        function onMouseMove(event) {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = (event.clientY / window.innerHeight) * 2 - 1;

            // æ›´æ–°é¼ æ ‡ä½ç½®å‘é‡ (ç”¨äºç‚¹å‡»æ£€æµ‹)
            mouse.x = mouseX;
            mouse.y = -mouseY;

            // æ‹–æ‹½æ—‹è½¬
            if (isDragging) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;

                island.rotation.y += deltaX * 0.005;
                island.rotation.x += deltaY * 0.005;
                island.rotation.x = Math.max(-0.3, Math.min(0.3, island.rotation.x));

                previousMousePosition = { x: event.clientX, y: event.clientY };
            }

            // æ£€æµ‹é¼ æ ‡æ‚¬åœçš„è§’è‰²
            checkCharacterHover(event);
        }

        // ==================== æ£€æµ‹è§’è‰²æ‚¬åœ ====================
        function checkCharacterHover(event) {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(characterMeshes);

            if (intersects.length > 0) {
                let hoveredCharacter = intersects[0].object.userData.character;
                if (hoveredCharacter && hoveredCharacter.userData) {
                    nameTag.style.display = 'block';
                    nameTag.style.left = event.clientX + 15 + 'px';
                    nameTag.style.top = event.clientY - 15 + 'px';
                    nameTag.textContent = hoveredCharacter.userData.name;
                    document.body.style.cursor = 'pointer';
                }
            } else {
                nameTag.style.display = 'none';
                document.body.style.cursor = isDragging ? 'grabbing' : 'crosshair';
            }
        }

        // ==================== é¼ æ ‡æŒ‰ä¸‹ ====================
        function onMouseDown(event) {
            if (event.button === 0) {
                isDragging = true;
                previousMousePosition = { x: event.clientX, y: event.clientY };
                document.body.style.cursor = 'grabbing';
            }
        }

        // ==================== é¼ æ ‡é‡Šæ”¾ ====================
        function onMouseUp() {
            isDragging = false;
            document.body.style.cursor = 'crosshair';
        }

        // ==================== é¼ æ ‡æ»šè½® ====================
        function onMouseWheel(event) {
            const zoomSpeed = 0.001;
            camera.position.multiplyScalar(1 + event.deltaY * zoomSpeed);

            // é™åˆ¶ç¼©æ”¾èŒƒå›´
            const distance = camera.position.length();
            if (distance < 20) {
                camera.position.setLength(20);
            } else if (distance > 60) {
                camera.position.setLength(60);
            }
        }

        // ==================== é¼ æ ‡ç‚¹å‡» ====================
        function onMouseClick(event) {
            if (isDragging) return;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(characterMeshes);

            if (intersects.length > 0) {
                let clickedCharacter = intersects[0].object.userData.character;
                if (clickedCharacter && clickedCharacter.userData) {
                    showDialog(clickedCharacter.userData);
                    playCharacterAnimation(clickedCharacter);
                }
            }
        }

        // ==================== è§’è‰²ç‚¹å‡»åŠ¨ç”» ====================
        function playCharacterAnimation(character) {
            // ä¿å­˜åŸå§‹Yä½ç½®
            const originalY = character.userData.position.y;

            // è·³è·ƒåŠ¨ç”»ï¼ˆä¸´æ—¶æ€§çš„ï¼‰
            gsap.to(character.position, {
                y: originalY + 1.5,
                duration: 0.2,
                yoyo: true,
                repeat: 1,
                ease: "power2.out",
                onComplete: () => {
                    // åŠ¨ç”»ç»“æŸåæ¢å¤åˆ°è·‘åŠ¨çš„Yä½ç½®
                    character.position.y = originalY;
                }
            });

            // ç¼©æ”¾åŠ¨ç”»
            gsap.to(character.scale, {
                x: character.scale.x * 1.3,
                y: character.scale.y * 1.3,
                z: character.scale.z * 1.3,
                duration: 0.15,
                yoyo: true,
                repeat: 1
            });
        }

        // ==================== æ˜¾ç¤º RPG é£æ ¼å¯¹è¯æ¡† ====================
        function showDialog(characterData) {
            const overlay = document.getElementById('rpg-overlay');
            const dialogContainer = document.getElementById('rpg-dialog-container');
            const infoCard = document.getElementById('character-info-card');
            const dialogText = document.getElementById('rpg-dialog-text');
            const characterName = document.getElementById('rpg-character-name');
            const avatarContainer = document.getElementById('dialog-avatar');

            // æ›´æ–°è§’è‰²ä¿¡æ¯å¡ç‰‡
            document.getElementById('info-name').textContent = characterData.name;
            document.getElementById('info-type').textContent = characterData.type;
            document.getElementById('info-personality').textContent = characterData.personality;
            document.getElementById('info-cute').textContent = characterData.cute + '%';
            document.getElementById('info-energy').textContent = characterData.energy + '%';
            document.getElementById('cute-bar').style.width = characterData.cute + '%';
            document.getElementById('energy-bar').style.width = characterData.energy + '%';
            document.getElementById('info-description').innerHTML = characterData.description;

            // æ›´æ–°å¯¹è¯æ¡†åç§°
            characterName.textContent = characterData.name;

            // åˆ›å»ºè§’è‰²å¤´åƒ
            createCharacterAvatar(characterData, avatarContainer);

            // æ¸…ç©ºå¯¹è¯æ–‡æœ¬
            dialogText.textContent = '';

            // æ˜¾ç¤ºé®ç½©å±‚
            overlay.classList.add('show');

            // å»¶è¿Ÿæ˜¾ç¤ºå¯¹è¯æ¡†ï¼ˆä»å°åˆ°å¤§çš„åŠ¨ç”»ï¼‰
            setTimeout(() => {
                dialogContainer.classList.add('show');
            }, 100);

            // å»¶è¿Ÿæ˜¾ç¤ºä¿¡æ¯å¡ç‰‡
            setTimeout(() => {
                infoCard.classList.add('show');
            }, 200);

            // æ‰“å­—æœºæ•ˆæœ
            let i = 0;
            const text = characterData.message;
            const typeWriter = () => {
                if (i < text.length) {
                    dialogText.textContent += text.charAt(i);
                    i++;
                    setTimeout(typeWriter, 30);
                }
            };
            setTimeout(typeWriter, 400);
        }

        // ==================== åˆ›å»ºè§’è‰²å¤´åƒ Canvas ====================
        function createCharacterAvatar(config, container) {
            // æ¸…ç©ºå®¹å™¨
            container.innerHTML = '';

            const canvasSize = 150;
            const canvas = document.createElement('canvas');
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            const ctx = canvas.getContext('2d');

            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvasSize, canvasSize);

            // èƒŒæ™¯
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvasSize, canvasSize);

            // ç»˜åˆ¶æ›´å¤§çš„è§’è‰²å¤´åƒ
            const centerX = canvasSize / 2;
            const centerY = canvasSize / 2;

            // æ ¹æ®è§’è‰²ç±»å‹ç»˜åˆ¶
            if (config.name === 'ç”°çªå¤´') {
                // æŸ¯åŸºå°ç‹—å¤´åƒ
                ctx.fillStyle = '#c4a882';
                for (let i = 0; i < 300; i++) {
                    const x = centerX + (Math.random() - 0.5) * 80;
                    const y = centerY + 20 + (Math.random() - 0.5) * 45;
                    ctx.fillRect(Math.floor(x / 4) * 4, Math.floor(y / 4) * 4, 4, 4);
                }

                ctx.fillStyle = '#d8bc96';
                for (let i = 0; i < 220; i++) {
                    const x = centerX + (Math.random() - 0.5) * 70;
                    const y = centerY - 15 + (Math.random() - 0.5) * 55;
                    ctx.fillRect(Math.floor(x / 4) * 4, Math.floor(y / 4) * 4, 4, 4);
                }

                // å¤§è€³æœµ
                ctx.fillStyle = '#c4a882';
                for (let i = 0; i < 60; i++) {
                    const x = centerX - 40 + (Math.random() - 0.5) * 25;
                    const y = centerY - 50 + (Math.random() - 0.5) * 30;
                    ctx.fillRect(Math.floor(x / 4) * 4, Math.floor(y / 4) * 4, 6, 6);
                }
                for (let i = 0; i < 60; i++) {
                    const x = centerX + 40 + (Math.random() - 0.5) * 25;
                    const y = centerY - 50 + (Math.random() - 0.5) * 30;
                    ctx.fillRect(Math.floor(x / 4) * 4, Math.floor(y / 4) * 4, 6, 6);
                }

                // çœ¼ç›
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(centerX - 15, centerY - 25, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(centerX + 15, centerY - 25, 10, 0, Math.PI * 2);
                ctx.fill();

                // é«˜å…‰
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(centerX - 18, centerY - 28, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(centerX + 12, centerY - 28, 4, 0, Math.PI * 2);
                ctx.fill();

                // é¼»å­
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(centerX, centerY - 8, 6, 0, Math.PI * 2);
                ctx.fill();

                // å˜´å·´
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(centerX - 8, centerY, 6, 0, Math.PI);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(centerX + 8, centerY, 6, 0, Math.PI);
                ctx.stroke();

                // èˆŒå¤´
                ctx.fillStyle = '#ff9999';
                ctx.beginPath();
                ctx.ellipse(centerX, centerY + 10, 8, 10, 0, 0, Math.PI * 2);
                ctx.fill();

            } else {
                // çŒ«å’ªå¤´åƒ
                const bodyColor = config.name === 'ç”°è±†åŒ…' ? '#d0d0d0' : (config.name === 'æèŠ±å·' ? '#e8d8f0' : '#888888');
                const headColor = config.name === 'ç”°è±†åŒ…' ? '#e0e0e0' : (config.name === 'æèŠ±å·' ? '#f0e8f8' : '#999999');

                // èº«ä½“
                ctx.fillStyle = bodyColor;
                for (let i = 0; i < 250; i++) {
                    const x = centerX + (Math.random() - 0.5) * 75;
                    const y = centerY + 25 + (Math.random() - 0.5) * 35;
                    ctx.fillRect(Math.floor(x / 4) * 4, Math.floor(y / 4) * 4, 4, 4);
                }

                // å¤´
                ctx.fillStyle = headColor;
                for (let i = 0; i < 220; i++) {
                    const x = centerX + (Math.random() - 0.5) * 72;
                    const y = centerY - 12 + (Math.random() - 0.5) * 58;
                    ctx.fillRect(Math.floor(x / 4) * 4, Math.floor(y / 4) * 4, 4, 4);
                }

                // è€³æœµ
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.moveTo(centerX - 45, centerY - 35);
                ctx.lineTo(centerX - 30, centerY - 75);
                ctx.lineTo(centerX - 12, centerY - 40);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(centerX + 45, centerY - 35);
                ctx.lineTo(centerX + 30, centerY - 75);
                ctx.lineTo(centerX + 12, centerY - 40);
                ctx.fill();

                // å†…è€³
                ctx.fillStyle = '#ffb6c1';
                ctx.beginPath();
                ctx.moveTo(centerX - 40, centerY - 38);
                ctx.lineTo(centerX - 30, centerY - 65);
                ctx.lineTo(centerX - 18, centerY - 42);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(centerX + 40, centerY - 38);
                ctx.lineTo(centerX + 30, centerY - 65);
                ctx.lineTo(centerX + 18, centerY - 42);
                ctx.fill();

                // çœ¼ç›
                ctx.fillStyle = '#2c5aa0';
                ctx.beginPath();
                ctx.ellipse(centerX - 15, centerY - 18, 9, 11, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(centerX + 15, centerY - 18, 9, 11, 0, 0, Math.PI * 2);
                ctx.fill();

                // ç³å­”
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.ellipse(centerX - 15, centerY - 18, 4, 8, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(centerX + 15, centerY - 18, 4, 8, 0, 0, Math.PI * 2);
                ctx.fill();

                // é«˜å…‰
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(centerX - 18, centerY - 21, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(centerX + 12, centerY - 21, 3, 0, Math.PI * 2);
                ctx.fill();

                // é¼»å­
                ctx.fillStyle = '#ffb6c1';
                ctx.beginPath();
                ctx.moveTo(centerX, centerY + 2);
                ctx.lineTo(centerX - 5, centerY + 8);
                ctx.lineTo(centerX + 5, centerY + 8);
                ctx.fill();

                // å˜´å·´
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY + 8);
                ctx.lineTo(centerX, centerY + 18);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(centerX - 8, centerY + 18, 8, 0, Math.PI);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(centerX + 8, centerY + 18, 8, 0, Math.PI);
                ctx.stroke();

                // èƒ¡é¡»
                ctx.strokeStyle = '#888';
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(centerX - 30, centerY - 3 + i * 8);
                    ctx.lineTo(centerX - 55, centerY - 8 + i * 8);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(centerX + 30, centerY - 3 + i * 8);
                    ctx.lineTo(centerX + 55, centerY - 8 + i * 8);
                    ctx.stroke();
                }
            }

            container.appendChild(canvas);
        }

        // ==================== å…³é—­ RPG å¯¹è¯æ¡† ====================
        function closeRPGDialog(event) {
            const overlay = document.getElementById('rpg-overlay');
            const dialogContainer = document.getElementById('rpg-dialog-container');
            const infoCard = document.getElementById('character-info-card');

            // éšè—åŠ¨ç”»
            dialogContainer.classList.remove('show');
            infoCard.classList.remove('show');

            // å»¶è¿Ÿéšè—é®ç½©å±‚
            setTimeout(() => {
                overlay.classList.remove('show');
            }, 300);
        }

        // ==================== åŠ¨ç”»å¾ªç¯ ====================
        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();

            // æ›´æ–°é›ªèŠ±
            updateSnowflakes(snowflakes, time);

            // è®©åŠ¨ç‰©ä»¬åœ¨ç¯å½¢è·‘é“ä¸Šè·‘åŠ¨
            characters.forEach(character => {
                const config = character.userData;
                if (config.orbitRadius && config.orbitSpeed !== undefined) {
                    const angle = time * config.orbitSpeed + config.orbitOffset;
                    character.position.x = Math.cos(angle) * config.orbitRadius;
                    character.position.z = 8 + Math.sin(angle) * config.orbitRadius;
                    // è®©è§’è‰²æœå‘è·‘åŠ¨æ–¹å‘
                    character.rotation.y = -angle + Math.PI / 2;
                }
            });

            // é¼ æ ‡è§†å·®æ•ˆæœï¼ˆå½“æ²¡æœ‰æ‹–æ‹½æ—¶ï¼‰
            if (!isDragging) {
                targetRotationY = mouseX * 0.15;
                targetRotationX = mouseY * 0.08;

                if (island) {
                    island.rotation.y += (targetRotationY - island.rotation.y) * 0.03;
                    island.rotation.x += ((targetRotationX * 0.5) - island.rotation.x) * 0.03;

                    // é™åˆ¶Xè½´æ—‹è½¬
                    island.rotation.x = Math.max(-0.2, Math.min(0.2, island.rotation.x));
                }
            }

            // è®©è§’è‰²å¹³é¢å§‹ç»ˆé¢å‘ç›¸æœº
            characters.forEach(character => {
                character.children.forEach(child => {
                    if (child.isMesh) {
                        child.lookAt(camera.position);
                    }
                });
            });

            renderer.render(scene, camera);
        }

        // ==================== å¯åŠ¨ ====================
        init();
        animate();

        // å…¨å±€å‡½æ•°
        window.closeRPGDialog = closeRPGDialog;

        // éŸ³ä¹æ§åˆ¶
        let musicPlaying = false;
        const musicAudio = document.getElementById('christmas-music');
        const musicToggle = document.getElementById('music-toggle');

        function toggleMusic() {
            if (musicPlaying) {
                musicAudio.pause();
                musicToggle.textContent = 'ğŸµ éŸ³ä¹: OFF';
                musicPlaying = false;
            } else {
                musicAudio.volume = 0.3;
                musicAudio.play().catch(e => {
                    console.log('éŸ³ä¹æ’­æ”¾éœ€è¦ç”¨æˆ·äº¤äº’:', e);
                });
                musicToggle.textContent = 'ğŸµ éŸ³ä¹: ON';
                musicPlaying = true;
            }
        }

        window.toggleMusic = toggleMusic;
    </script>
</body>
</html>