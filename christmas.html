<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas - æ‰‹åŠ¿äº’åŠ¨ç²’å­</title>
    
    <!-- åŠ è½½ Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- åŠ è½½ MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- å¼•å…¥ Google Fonts å¢åŠ èŠ‚æ—¥æ°›å›´ -->
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Mountains+of+Christmas:wght@700&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #1a0505 0%, #000000 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }

        #input_video {
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0; 
            pointer-events: none;
            z-index: -1;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        /* æ‘„åƒå¤´å°çª— */
        #camera-preview {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 215, 0, 0.3); /* é‡‘è‰²è¾¹æ¡† */
            z-index: 10;
            transform: scaleX(-1);
            background: #000;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.2);
        }
        #camera-preview video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* èŠ‚æ—¥é£æ ¼ UI é¢æ¿ */
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            background: rgba(40, 0, 0, 0.6); /* æ·±çº¢åŠé€æ˜ */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 16px;
            border: 1px solid rgba(255, 215, 0, 0.2); /* é‡‘è‰²æè¾¹ */
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);
            z-index: 20;
            transition: transform 0.3s ease;
        }

        /* åœ£è¯æ ‡é¢˜ */
        h1 {
            font-family: 'Great Vibes', cursive; /* èŠ‚æ—¥æ‰‹å†™ä½“ */
            font-size: 2.5rem;
            margin: 0 0 10px 0;
            font-weight: 400;
            text-align: center;
            background: linear-gradient(to right, #ff0000, #ffcc00, #ff0000);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            animation: shine 3s linear infinite;
        }

        @keyframes shine {
            0% { background-position: 0% center; }
            100% { background-position: 200% center; }
        }

        .subtitle {
            text-align: center;
            font-family: 'Mountains of Christmas', cursive;
            color: #ccc;
            margin-bottom: 20px;
            font-size: 1.1rem;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            font-size: 0.9rem;
            margin-bottom: 8px;
            color: #ffcccc;
        }

        .shape-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 10px;
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .btn:hover {
            background: rgba(255, 0, 50, 0.3);
            border-color: rgba(255, 0, 50, 0.5);
        }

        .btn.active {
            background: linear-gradient(135deg, #d40000, #800000);
            border-color: #ffcc00;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.4);
        }

        input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 8px;
            background: none;
            cursor: pointer;
        }

        #status {
            margin-top: 15px;
            font-size: 0.8rem;
            color: #ffaaaa;
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(0,0,0,0.3);
            padding: 8px;
            border-radius: 6px;
        }
        .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #555;
        }
        .dot.active {
            background-color: #00ff88;
            box-shadow: 0 0 8px #00ff88;
        }

        .fullscreen-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,0,0,0.2);
            border: 1px solid rgba(255,215,0,0.3);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            color: #ffcc00;
            cursor: pointer;
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        .fullscreen-btn:hover {
            background: rgba(255,0,0,0.5);
            transform: scale(1.1);
        }

        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #050000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.5s;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #330000;
            border-top: 4px solid #ff0000;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #toast {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 50, 50, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 100;
        }
    </style>
</head>
<body>

    <video id="input_video"></video>

    <div id="loader">
        <div class="spinner"></div>
        <p class="instruction" style="color: #ffaaaa; margin-top: 15px;">æ­£åœ¨å‡†å¤‡åœ£è¯é­”æ³•...</p>
        <p class="instruction" style="font-size: 0.8rem; color: #666;">éœ€è¦æ‘„åƒå¤´æƒé™æ¥æ•æ‰æ‰‹åŠ¿</p>
    </div>

    <div id="toast"></div>

    <div id="ui-panel">
        <h1>Merry Christmas</h1>
        <div class="subtitle">Interactive Particle Magic</div>
        
        <div class="control-group">
            <label>ğŸ„ èŠ‚æ—¥é€ å‹</label>
            <div class="shape-grid">
                <button class="btn active" onclick="setShape('tree', this)">ğŸ„ åœ£è¯æ ‘</button>
                <button class="btn" onclick="setShape('heart', this)">â¤ï¸ æ¸©æš–å¿ƒ</button>
                <button class="btn" onclick="setShape('star', this)">â­ ä¼¯åˆ©æ’ä¹‹æ˜Ÿ</button>
                <button class="btn" onclick="setShape('gift', this)">ğŸ ç¤¼ç‰©ç›’</button>
                <button class="btn" onclick="setShape('snowman', this)">â›„ é›ªäºº</button>
                <button class="btn" onclick="setShape('fireworks', this)">ğŸ† åº†å…¸çƒŸèŠ±</button>
            </div>
        </div>

        <div class="control-group">
            <label>âœ¨ æ°›å›´è‰²è°ƒ</label>
            <input type="color" id="colorPicker" value="#ff0033">
        </div>

        <div id="status">
            <div class="dot" id="status-dot"></div>
            <span id="status-text">ç­‰å¾…æ‰‹åŠ¿å”¤é†’...</span>
        </div>
        
        <p style="font-size: 0.75rem; color: #aaa; margin-top: 15px; line-height: 1.4;">
            äº’åŠ¨æŒ‡å—ï¼š<br>
            ğŸ‘ å¼ å¼€åŒæ‰‹ï¼šç²’å­æ‰©æ•£/å˜å¤§<br>
            ğŸ™ åŒæ‰‹åˆåï¼šç²’å­èšåˆ/å˜å°
        </p>
    </div>

    <button class="fullscreen-btn" onclick="toggleFullScreen()">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
        </svg>
    </button>

    <div id="camera-preview">
        <video id="preview_video" autoplay playsinline muted></video>
    </div>

    <div id="canvas-container"></div>

<script>
    // ================= CONFIG =================
    const PARTICLE_COUNT = 8000;   // åŸºç¡€ç²’å­æ•°é‡ (çº¢è‰²å…‰å°˜)
    const DECOR_COUNT = 300;       // è£…é¥°ç‰©ç²’å­æ•°é‡ (å¤§å›¾æ ‡)
    const BASE_COLOR = 0xff0033;   // é»˜è®¤åœ£è¯çº¢
    
    // è£…é¥°ç‰©åˆ—è¡¨
    const DECOR_ICONS = ['ğŸ„', 'ğŸ§¦', 'ğŸ', 'ğŸ±', 'ğŸ¶', 'â„ï¸', 'â­', 'ğŸ””'];

    // ================= GLOBALS =================
    let scene, camera, renderer;
    let mainParticles, decorParticles; // ä¸¤ä¸ªç²’å­ç³»ç»Ÿ
    
    // å­˜å‚¨ä½ç½®æ•°æ®
    // mainPoints: { current: [], target: [] }
    // decorPoints: { current: [], target: [], types: [] }
    let mainData = { current: [], target: [] };
    let decorData = { current: [], target: [] };

    let mouseX = 0, mouseY = 0;
    let handInteractionFactor = 0; 
    let isHandsDetected = false;
    let currentShape = 'tree'; // é»˜è®¤åœ£è¯æ ‘
    
    const shapes = {}; // ç¼“å­˜è®¡ç®—å¥½çš„å½¢çŠ¶æ•°æ®

    // ================= UTILS =================
    function showToast(msg) {
        const toast = document.getElementById('toast');
        toast.innerText = msg;
        toast.style.opacity = '1';
        setTimeout(() => toast.style.opacity = '0', 3000);
    }

    // ç”Ÿæˆ Emoji çº¹ç†
    function createEmojiTexture(emoji) {
        const canvas = document.createElement('canvas');
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext('2d');
        
        ctx.font = '100px serif'; // å¤§å­—ä½“
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = 'white'; 
        ctx.fillText(emoji, 64, 70); // ç»˜åˆ¶ Emoji
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    // ç”ŸæˆåŸºç¡€å…‰å°˜çº¹ç†
    function createGlowTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
        grad.addColorStop(0, 'rgba(255,255,255,1)');
        grad.addColorStop(0.2, 'rgba(255,255,255,0.8)');
        grad.addColorStop(0.5, 'rgba(255,255,255,0.2)');
        grad.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,32,32);
        return new THREE.CanvasTexture(canvas);
    }

    // ================= THREE.JS SETUP =================
    function initThree() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        // å¢åŠ ä¸€ç‚¹çº¢è‰²ç¯å¢ƒé›¾
        scene.fog = new THREE.FogExp2(0x1a0505, 0.002);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 35;
        camera.position.y = 5;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        createParticleSystems();

        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('mousemove', onMouseMove, false);
        
        document.getElementById('colorPicker').addEventListener('input', (e) => {
            if(mainParticles) mainParticles.material.color.set(e.target.value);
        });

        animate();
    }

    function createParticleSystems() {
        // 1. ç³»ç»ŸAï¼šåŸºç¡€çº¢è‰²å…‰å°˜ (Main)
        const mainGeo = new THREE.BufferGeometry();
        const mainPos = new Float32Array(PARTICLE_COUNT * 3);
        
        for(let i=0; i<PARTICLE_COUNT; i++) {
            mainPos[i*3] = (Math.random()-0.5)*100;
            mainPos[i*3+1] = (Math.random()-0.5)*100;
            mainPos[i*3+2] = (Math.random()-0.5)*100;
            
            mainData.current.push({
                x: mainPos[i*3], y: mainPos[i*3+1], z: mainPos[i*3+2]
            });
        }
        mainGeo.setAttribute('position', new THREE.BufferAttribute(mainPos, 3));
        
        const mainMat = new THREE.PointsMaterial({
            color: BASE_COLOR,
            size: 0.35,
            map: createGlowTexture(),
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        mainParticles = new THREE.Points(mainGeo, mainMat);
        scene.add(mainParticles);

        // 2. ç³»ç»ŸBï¼šè£…é¥°ç‰© (Decor) - æˆ‘ä»¬éœ€è¦åˆ›å»ºå¤šä¸ª Points å¯¹è±¡ï¼Œå› ä¸º Emoji çº¹ç†ä¸åŒ
        // ä¸ºäº†ç®€åŒ–æ€§èƒ½ï¼Œæˆ‘ä»¬å°†éšæœºæŒ‘é€‰ä¸€ä¸ª Emoji ä½œä¸ºâ€œä¸»è£…é¥°â€ï¼Œæˆ–è€…åˆ†æ‰¹åˆ›å»ºã€‚
        // ä¸ºäº† Best Practice å’Œå•æ–‡ä»¶ç®€æ´æ€§ï¼Œè¿™é‡Œä½¿ç”¨ä¸€ä¸ª Points ç³»ç»Ÿï¼Œ
        // ä½†ä¸ºäº†æ˜¾ç¤ºä¸åŒ Emojiï¼Œæˆ‘ä»¬ç”¨ Canvas ç»˜åˆ¶ä¸€ä¸ªåŒ…å«æ‰€æœ‰å›¾æ ‡çš„çº¹ç†å›¾é›†ä¼šæ¯”è¾ƒå¤æ‚ã€‚
        // ç®€åŒ–æ–¹æ¡ˆï¼šåˆ›å»º 5 ä¸ªå°çš„ Points ç³»ç»Ÿï¼Œæ¯ä¸ªå¯¹åº”ä¸€ç§ Emojiã€‚
        
        decorParticles = [];
        
        // éšæœºåˆ†é…å›¾æ ‡ç±»å‹ç»™ DECOR_COUNT ä¸ªç²’å­
        // è¿™é‡Œä¸ºäº†ç®€å•ï¼Œæˆ‘ä»¬å¾ªç¯åˆ›å»º DECOR_ICONS.length ä¸ªç²’å­ç»„
        
        DECOR_ICONS.forEach((icon, index) => {
            const countPerIcon = Math.floor(DECOR_COUNT / DECOR_ICONS.length);
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(countPerIcon * 3);
            
            // è®°å½•è¿™äº›ç²’å­åœ¨å…¨å±€ decorData ä¸­çš„ç´¢å¼•åç§»
            const offset = index * countPerIcon;

            for(let i=0; i<countPerIcon; i++) {
                // åˆå§‹ä¹±åº
                const x = (Math.random()-0.5)*100;
                const y = (Math.random()-0.5)*100;
                const z = (Math.random()-0.5)*100;
                pos[i*3] = x; pos[i*3+1] = y; pos[i*3+2] = z;

                // å­˜å…¥å…¨å±€ decorData
                decorData.current[offset + i] = { x, y, z };
            }
            
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            
            const mat = new THREE.PointsMaterial({
                color: 0xffffff, // å›¾æ ‡ä¿æŒåŸè‰²
                size: 1.5,       // å¤§ä¸€ç‚¹
                map: createEmojiTexture(icon),
                transparent: true,
                opacity: 1.0,
                depthWrite: false
            });
            
            const points = new THREE.Points(geo, mat);
            // å­˜ä¸ªå¼•ç”¨æ–¹ä¾¿ update
            points.userData = { offset: offset, count: countPerIcon };
            scene.add(points);
            decorParticles.push(points);
        });

        // ç”Ÿæˆæ‰€æœ‰å½¢çŠ¶æ•°æ®
        generateAllShapes();
        
        // åˆå§‹è®¾ç½®
        updateTargetPositions('tree');
    }

    // ================= SHAPE GENERATION =================
    function generateAllShapes() {
        const totalPoints = PARTICLE_COUNT;
        const totalDecor = decorData.current.length; // å®é™…è£…é¥°ç‰©æ€»æ•°

        // è¾…åŠ©ï¼šç”Ÿæˆå½¢çŠ¶ç‚¹é›†çš„å‡½æ•°
        // type: 'main' | 'decor' (decor é€šå¸¸åœ¨è¡¨é¢ï¼Œmain å¡«å……ä½“ç§¯æˆ–è¡¨é¢)
        const getShapePoints = (shapeType, count, isDecor) => {
            const pts = [];
            for(let i=0; i<count; i++) {
                let p = {x:0, y:0, z:0};
                const ratio = i / count;

                if (shapeType === 'tree') {
                    // èºæ—‹åœ†é”¥
                    // é«˜åº¦èŒƒå›´ -15 åˆ° 15
                    const h = 30;
                    const y = (ratio * h) - (h/2); // -15 to 15
                    // åŠå¾„éšé«˜åº¦å˜å° (ä¸Šå°ä¸‹å¤§)
                    // y=-15(åº•), r=large; y=15(é¡¶), r=0
                    const radius = (15 - y) * 0.45; 
                    
                    if (isDecor) {
                        // è£…é¥°ç‰©è¦åœ¨è¡¨é¢
                        const angle = ratio * Math.PI * 15; // ç»•åœˆåœˆ
                        p.x = Math.cos(angle) * radius;
                        p.z = Math.sin(angle) * radius;
                        p.y = y;
                    } else {
                        // å…‰å°˜å¡«å……ä½“ç§¯
                        const angle = Math.random() * Math.PI * 2;
                        const r = Math.random() * radius; // å†…éƒ¨å¡«å……
                        p.x = Math.cos(angle) * r;
                        p.z = Math.sin(angle) * r;
                        p.y = y - 2; // ç¨å¾®ä¸‹æ²‰ä¸€ç‚¹
                    }

                } else if (shapeType === 'heart') {
                    // å¿ƒå½¢
                    let t = Math.random() * Math.PI * 2;
                    let r = isDecor ? 15 : Math.sqrt(Math.random()) * 15; // è£…é¥°åœ¨è¾¹ä¸Š
                    let x = 16 * Math.pow(Math.sin(t), 3);
                    let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    let z = (Math.random() - 0.5) * (isDecor ? 2 : 5);
                    p = { x: x * (r/16), y: y * (r/16), z: z };

                } else if (shapeType === 'star') {
                    // äº”è§’æ˜Ÿ (ç®€å•çš„å‚æ•°åŒ–)
                    const angle = Math.random() * Math.PI * 2;
                    // åŠå¾„åœ¨ 5 ä¸ªè§’ä¹‹é—´å˜åŒ–
                    // r = a / (cos(angle % (2PI/5) - PI/5)) ç±»ä¼¼é€»è¾‘ï¼Œç®€åŒ–ç‰ˆï¼š
                    const section = (Math.atan2(Math.sin(angle), Math.cos(angle)) + Math.PI) / (Math.PI * 2 / 5);
                    const localAngle = (section % 1 - 0.5) * (Math.PI * 2 / 5);
                    // æ˜Ÿæ˜Ÿå½¢çŠ¶å‡½æ•°
                    const starR = 10 / Math.cos(localAngle); 
                    const limit = (Math.abs(localAngle) > 0.5) ? 6 : 14; 
                    
                    let r = isDecor ? limit : Math.random() * limit;
                    
                    p.x = r * Math.cos(angle);
                    p.y = r * Math.sin(angle);
                    p.z = (Math.random()-0.5) * 2;

                } else if (shapeType === 'gift') {
                    // ç«‹æ–¹ä½“
                    const size = 12;
                    if (isDecor) {
                        // è£…é¥°åœ¨æ£±ä¸Šæˆ–é¢ä¸Š
                        const face = Math.floor(Math.random()*6);
                        // ç®€åŒ–ï¼šéšæœºè¡¨é¢
                        p.x = (Math.random()-0.5)*size*2;
                        p.y = (Math.random()-0.5)*size*2;
                        p.z = (Math.random()-0.5)*size*2;
                        // å¼ºåˆ¶æ¨åˆ°è¡¨é¢
                        const axis = Math.floor(Math.random()*3);
                        if(axis===0) p.x = Math.sign(p.x)*size;
                        if(axis===1) p.y = Math.sign(p.y)*size;
                        if(axis===2) p.z = Math.sign(p.z)*size;
                    } else {
                        // å¡«å……
                        p.x = (Math.random()-0.5)*size*2;
                        p.y = (Math.random()-0.5)*size*2;
                        p.z = (Math.random()-0.5)*size*2;
                    }

                } else if (shapeType === 'snowman') {
                    // ä¸¤ä¸ªçƒå èµ·æ¥
                    const isTop = Math.random() > 0.6;
                    const r = isTop ? 5 : 8;
                    const cy = isTop ? 8 : -5;
                    
                    const phi = Math.acos(-1 + (2 * Math.random()));
                    const theta = Math.sqrt(count * Math.PI) * phi;
                    
                    const rad = isDecor ? r : r * Math.cbrt(Math.random()); // è£…é¥°åœ¨è¡¨é¢
                    
                    p.x = rad * Math.cos(theta) * Math.sin(phi);
                    p.z = rad * Math.sin(theta) * Math.sin(phi);
                    p.y = rad * Math.cos(phi) + cy;
                    
                } else if (shapeType === 'fireworks') {
                    // çƒä½“çˆ†ç‚¸
                    const phi = Math.acos(-1 + (2 * Math.random()));
                    const theta = Math.sqrt(count * Math.PI) * phi;
                    const r = isDecor ? 15 : 15 * Math.cbrt(Math.random());
                    
                    p.x = r * Math.cos(theta) * Math.sin(phi);
                    p.y = r * Math.sin(theta) * Math.sin(phi);
                    p.z = r * Math.cos(phi);
                }

                pts.push(p);
            }
            return pts;
        };

        const shapeTypes = ['tree', 'heart', 'star', 'gift', 'snowman', 'fireworks'];
        
        shapeTypes.forEach(type => {
            shapes[type] = {
                main: getShapePoints(type, PARTICLE_COUNT, false),
                decor: getShapePoints(type, totalDecor, true)
            };
        });
    }

    function updateTargetPositions(shapeName) {
        if (!shapes[shapeName]) return;
        mainData.target = shapes[shapeName].main;
        decorData.target = shapes[shapeName].decor;
    }

    window.setShape = function(shapeName, btn) {
        currentShape = shapeName;
        document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
        if(btn) btn.classList.add('active');
        updateTargetPositions(shapeName);
    }

    // ================= ANIMATION =================
    function animate() {
        requestAnimationFrame(animate);

        const time = Date.now() * 0.001;
        
        // äº¤äº’å› å­å¤„ç†
        let scaleFactor = 1;
        let scatter = 0;

        if (isHandsDetected) {
            // æ‰‹åŠ¿æ§åˆ¶
            scaleFactor = 0.8 + (handInteractionFactor * 2.5); // 0.8x åˆ° 3.3x
            scatter = Math.max(0, (handInteractionFactor - 0.7) * 0.8);
        } else {
            // é¼ æ ‡å¾®åŠ¨
            scaleFactor = 1 + (mouseX * 0.1); 
        }

        // 1. æ›´æ–°ä¸»ç²’å­ (å…‰å°˜)
        const mainPositions = mainParticles.geometry.attributes.position.array;
        
        // ä¼˜åŒ–ï¼šåˆ†æ‰¹æ›´æ–°æˆ–å…¨éƒ¨æ›´æ–°
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const target = mainData.target[i];
            const current = mainData.current[i];
            
            // ç›®æ ‡ä½ç½®è®¡ç®—
            let tx = target.x; let ty = target.y; let tz = target.z;

            // çƒŸèŠ±ç‰¹æ•ˆ
            if (currentShape === 'fireworks') {
                const pulse = Math.sin(time*3) * 0.2 + 1;
                tx *= pulse; ty *= pulse; tz *= pulse;
            }

            // åº”ç”¨ç¼©æ”¾
            tx *= scaleFactor; ty *= scaleFactor; tz *= scaleFactor;

            // ç§»åŠ¨é€Ÿåº¦
            const speed = 0.06;
            current.x += (tx - current.x) * speed;
            current.y += (ty - current.y) * speed;
            current.z += (tz - current.z) * speed;

            // å™ªç‚¹/æ¼‚æµ® (æ¨¡æ‹Ÿä¸‹é›ªæˆ–ç°å°˜)
            current.x += Math.sin(time + i) * 0.01;
            current.y -= 0.02; // å¾®å¾®ä¸‹è½
            if(current.y < -20) current.y = 20; // å¾ªç¯

            // å†™å…¥
            // å¦‚æœæœ‰ scatter éšæœºæ•£å¼€
            const sx = current.x + (Math.random()-0.5)*scatter*10;
            const sy = current.y + (Math.random()-0.5)*scatter*10;
            const sz = current.z + (Math.random()-0.5)*scatter*10;

            mainPositions[i*3] = sx;
            mainPositions[i*3+1] = sy;
            mainPositions[i*3+2] = sz;
        }
        mainParticles.geometry.attributes.position.needsUpdate = true;
        // æ•´ä½“æ—‹è½¬
        mainParticles.rotation.y = time * 0.1;


        // 2. æ›´æ–°è£…é¥°ç‰©ç²’å­ (Sprites)
        decorParticles.forEach(points => {
            const positions = points.geometry.attributes.position.array;
            const offset = points.userData.offset;
            const count = points.userData.count;

            for (let i = 0; i < count; i++) {
                const globalIndex = offset + i;
                const target = decorData.target[globalIndex];
                const current = decorData.current[globalIndex];

                let tx = target.x; let ty = target.y; let tz = target.z;
                
                if (currentShape === 'fireworks') {
                    const pulse = Math.sin(time*3) * 0.2 + 1;
                    tx *= pulse; ty *= pulse; tz *= pulse;
                }

                tx *= scaleFactor; ty *= scaleFactor; tz *= scaleFactor;

                // è£…é¥°ç‰©ç¨å¾®æ…¢ä¸€ç‚¹ï¼Œæœ‰ç§æ‚¬æµ®æ„Ÿ
                const speed = 0.04;
                current.x += (tx - current.x) * speed;
                current.y += (ty - current.y) * speed;
                current.z += (tz - current.z) * speed;

                // è£…é¥°ç‰©è‡ªæ—‹/æ™ƒåŠ¨
                const wobble = Math.sin(time*2 + i)*0.2;
                
                const sx = current.x + (Math.random()-0.5)*scatter*15;
                const sy = current.y + wobble + (Math.random()-0.5)*scatter*15;
                const sz = current.z + (Math.random()-0.5)*scatter*15;

                positions[i*3] = sx;
                positions[i*3+1] = sy;
                positions[i*3+2] = sz;
            }
            points.geometry.attributes.position.needsUpdate = true;
            
            // è£…é¥°ç‰©è·Ÿéšä¸»ç²’å­æ—‹è½¬
            points.rotation.y = time * 0.1;
        });

        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onMouseMove(event) {
        if(!isHandsDetected) {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
        }
    }

    window.toggleFullScreen = function() {
        // é¦–å…ˆæ£€æŸ¥æµè§ˆå™¨APIæ˜¯å¦å¯ç”¨/å…è®¸
        if (document.fullscreenEnabled === false) {
            showToast("å½“å‰ç¯å¢ƒé™åˆ¶äº†å…¨å±åŠŸèƒ½");
            return;
        }

        try {
            if (!document.fullscreenElement) {
                const promise = document.documentElement.requestFullscreen();
                // ç¡®ä¿è¿”å›çš„æ˜¯ Promise å†è¿›è¡Œ catch
                if (promise && typeof promise.catch === 'function') {
                    promise.catch(err => {
                        console.warn("å…¨å±è¢«æ‹¦æˆª:", err);
                        showToast("æ— æ³•è¿›å…¥å…¨å± (é¢„è§ˆç¯å¢ƒé™åˆ¶)");
                    });
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen().catch(err => console.warn(err));
                }
            }
        } catch(e) {
            console.warn("å…¨å±åŒæ­¥é”™è¯¯:", e);
            showToast("æ— æ³•è¿›å…¥å…¨å±");
        }
    }

    // ================= MEDIAPIPE =================
    const videoElement = document.getElementById('input_video');
    const loader = document.getElementById('loader');

    function onResults(results) {
        if(loader.style.opacity !== '0') {
            loader.style.opacity = '0';
            setTimeout(() => loader.style.display = 'none', 500);
        }

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            isHandsDetected = true;
            document.getElementById('status-text').innerText = "æ‰‹åŠ¿å·²è¿æ¥";
            document.getElementById('status-dot').classList.add('active');

            let distance = 0;
            if (results.multiHandLandmarks.length === 2) {
                const hand1 = results.multiHandLandmarks[0][0];
                const hand2 = results.multiHandLandmarks[1][0];
                const dx = hand1.x - hand2.x;
                const dy = hand1.y - hand2.y;
                distance = Math.sqrt(dx*dx + dy*dy);
                // è°ƒæ•´çµæ•åº¦
                handInteractionFactor = Math.max(0, Math.min(1, (distance - 0.2) * 2.0));
            } else {
                const hand = results.multiHandLandmarks[0];
                const thumb = hand[4];
                const pinky = hand[20];
                const dx = thumb.x - pinky.x;
                const dy = thumb.y - pinky.y;
                distance = Math.sqrt(dx*dx + dy*dy);
                handInteractionFactor = Math.max(0, Math.min(1, (distance - 0.1) * 3));
            }
        } else {
            isHandsDetected = false;
            document.getElementById('status-text').innerText = "ç­‰å¾…æ‰‹åŠ¿...";
            document.getElementById('status-dot').classList.remove('active');
            handInteractionFactor *= 0.9;
        }
    }

    async function initMediaPipe() {
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });

        navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {
            document.getElementById('preview_video').srcObject = stream;
        });

        await cameraUtils.start();
    }

    // Start
    initThree();
    initMediaPipe();

</script>
</body>
</html>
