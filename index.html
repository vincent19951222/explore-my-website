<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boluopets: RPG Archipelago (Fixed)</title>
    <!-- å¼•å…¥åƒç´ å­—ä½“ -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&family=ZCOOL+KuaiLe&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            background: linear-gradient(to bottom, #4CA1AF 0%, #C4E0E5 100%);
            font-family: 'VT323', monospace;
            /* å…¨å±€åƒç´ å­—ä½“ */
            cursor: none;
            /* ä¿æŒè‡ªå®šä¹‰å…‰æ ‡ */
        }

        /* --- UI: Loading Screen --- */
        #loader {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #2b5876;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            transition: opacity 1s ease-out;
            pointer-events: none;
        }

        #loader h1 {
            color: white;
            font-size: 3rem;
            text-shadow: 4px 4px 0px #000;
            letter-spacing: 4px;
            margin-bottom: 10px;
        }

        #loader p {
            color: #fff;
            font-size: 1.5rem;
        }

        /* --- UI: Custom Cursor --- */
        #cursor {
            position: absolute;
            width: 32px;
            height: 32px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white' stroke='black' stroke-width='2'%3E%3Cpath d='M12 2v16m-4-4l4 4 4-4M5 14a8 8 0 0 1 14 0' /%3E%3Ccircle cx='12' cy='4' r='2' /%3E%3C/svg%3E");
            background-size: contain;
            background-repeat: no-repeat;
            pointer-events: none;
            z-index: 2000;
            transform: translate(-50%, -50%);
            transition: transform 0.1s;
        }

        /* --- UI: Helper Text (Removed) --- */

        /* --- UI: Ship Instructions (SVG Version) --- */
        .ship-container {
            position: absolute;
            bottom: 30px;
            z-index: 900;
            width: 160px;
            height: 180px;
            pointer-events: none;
            user-select: none;
            /* Debug border: border: 1px solid red; */
        }

        .ship-container.left {
            left: 40px;
        }

        .ship-container.right {
            right: 40px;
            /* Mirror the right ship so it faces inward */
            transform: scaleX(-1);
        }

        /* Fix text orientation for the mirrored right ship */
        .ship-container.right .flag-content {
            transform: scaleX(-1);
        }

        /* The SVG Boat */
        .ship-svg {
            width: 100%;
            height: 100%;
            overflow: visible;
            animation: ship-float 3s ease-in-out infinite;
        }

        /* Float Animation */
        @keyframes ship-float {

            0%,
            100% {
                transform: translateY(0) rotate(0deg);
            }

            50% {
                transform: translateY(-10px) rotate(1deg);
            }
        }

        /* The Speech Bubble / Flag Text */
        .ship-flag {
            position: absolute;
            top: -10px;
            /* Position above the mast */
            left: 65%;
            /* Align with mast */
            transform: translateX(-50%);
            z-index: 910;
            animation: ship-float 3s ease-in-out infinite;
            /* Sync with boat */
        }

        .flag-content {
            background: #fff;
            border: 3px solid #4a3c31;
            padding: 8px 12px;
            color: #4a3c31;
            font-family: 'ZCOOL KuaiLe', cursive;
            font-size: 1.5rem;
            border-radius: 8px;
            position: relative;
            box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.2);
            white-space: nowrap;
        }

        /* Triangle indicator */
        .flag-content::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 20px;
            /* Align with mast connection */
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 10px solid #4a3c31;
        }

        /* --- UI: RPG Dialog (Hidden by default) --- */
        #game-ui {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            max-width: 90%;
            height: 180px;
            background-color: #f4e4bc;
            /* ç¾Šçš®çº¸è‰² */
            border: 4px solid #4a3c31;
            /* æ·±è¤è‰²è¾¹æ¡† */
            box-shadow:
                inset 4px 4px 0px rgba(255, 255, 255, 0.5),
                inset -4px -4px 0px rgba(0, 0, 0, 0.2),
                8px 8px 0px rgba(0, 0, 0, 0.3);
            display: flex;
            padding: 10px;
            font-family: 'VT323', monospace;
            opacity: 0;
            pointer-events: none;
            /* åˆå§‹ä¸å¯ç‚¹å‡» */
            transition: opacity 0.3s;
            z-index: 1000;
        }

        #game-ui.active {
            opacity: 1;
            pointer-events: auto;
        }

        /* å·¦ä¾§å¤´åƒåŒº */
        #ui-avatar-container {
            width: 150px;
            height: 150px;
            border: 4px solid #4a3c31;
            background: #000;
            margin-right: 20px;
            flex-shrink: 0;
            position: relative;
            overflow: hidden;
        }

        #ui-avatar {
            width: 100%;
            height: 100%;
            object-fit: cover;
            image-rendering: pixelated;
            /* åƒç´ åŒ–å›¾ç‰‡ */
        }

        /* å³ä¾§å†…å®¹åŒº */
        #ui-content {
            flex-grow: 1;
            position: relative;
            color: #4a3c31;
        }

        #ui-title {
            margin: 0;
            font-size: 2rem;
            text-transform: uppercase;
            border-bottom: 2px dashed #4a3c31;
            padding-bottom: 5px;
            margin-bottom: 10px;
        }

        #ui-desc {
            font-size: 1.4rem;
            line-height: 1.2;
            margin: 0;
            min-height: 3.6rem;
            /* é¢„ç•™é«˜åº¦ */
        }

        /* é—ªçƒçš„å…‰æ ‡/æŒ‰é’® */
        #ui-btn {
            position: absolute;
            bottom: 0;
            right: 0;
            font-size: 1.2rem;
            background: #4a3c31;
            color: #f4e4bc;
            padding: 5px 10px;
            cursor: pointer;
            animation: blink 1s infinite;
            border: none;
            text-decoration: none;
            display: inline-block;
        }

        #ui-btn:hover {
            background: #ff5555;
            color: white;
            animation: none;
        }

        #ui-close {
            position: absolute;
            top: -20px;
            right: -20px;
            background: #ff5555;
            color: white;
            width: 40px;
            height: 40px;
            text-align: center;
            line-height: 40px;
            font-size: 1.5rem;
            border: 4px solid #fff;
            box-shadow: 4px 4px 0px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            display: none;
            /* åªåœ¨ active æ—¶æ˜¾ç¤ºé€»è¾‘ */
        }

        #game-ui.active #ui-close {
            display: block;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
                transform: translateY(0);
            }

            50% {
                opacity: 0.5;
                transform: translateY(2px);
            }
        }

        /* Canvas èƒŒæ™¯æ¨¡ç³Šæ•ˆæœ */
        canvas {
            transition: filter 0.8s ease;
        }

        canvas.blurred {
            filter: blur(8px) brightness(0.7);
        }

        /* æ‰“å­—æœºå…‰æ ‡é—ªçƒ */
        .typing-cursor::after {
            content: 'â–‹';
            animation: cursor-blink 1s step-end infinite;
            margin-left: 2px;
            color: #4a3c31;
        }

        @keyframes cursor-blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0;
            }
        }

        /* é®ç½©å±‚ï¼Œç”¨äºç‚¹å‡»é€€å‡º */
        #overlay-mask {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            z-index: 990;
            /* åœ¨ UI ä¹‹ä¸‹ */
        }

        #overlay-mask.active {
            display: block;
        }
    </style>
</head>

<body>

    <!-- 3D æ ‡é¢˜ -->
    <div id="title-3d-container">
        <h1 id="title-3d">åŠ¨ç‰©å›­é‡Œæœ‰ä»€ä¹ˆ</h1>
    </div>

    <style>
        /* 3D æ ‡é¢˜å®¹å™¨ */
        #title-3d-container {
            position: absolute;
            top: 40px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 100;
            pointer-events: none;
            perspective: 800px;
        }

        #title-3d {
            font-family: 'ZCOOL KuaiLe', cursive;
            font-size: 4rem;
            font-weight: 400;
            color: #fff;
            margin: 0;
            display: inline-block;
            /* 3D æ•ˆæœ */
            transform: rotateX(15deg) rotateY(0deg);
            transform-style: preserve-3d;
            /* å¤šå±‚æ–‡å­—é˜´å½±åˆ›å»ºç«‹ä½“æ„Ÿ */
            text-shadow:
                0 1px 0 #ccc,
                0 2px 0 #c9c9c9,
                0 3px 0 #bbb,
                0 4px 0 #b9b9b9,
                0 5px 0 #aaa,
                0 6px 1px rgba(0, 0, 0, .1),
                0 0 5px rgba(0, 0, 0, .1),
                0 1px 3px rgba(0, 0, 0, .3),
                0 3px 5px rgba(0, 0, 0, .2),
                0 5px 10px rgba(0, 0, 0, .25),
                0 10px 10px rgba(0, 0, 0, .2),
                0 20px 20px rgba(0, 0, 0, .15),
                4px 4px 0px #2b5876;
            /* åŠ¨ç”» */
            animation: title-float 4s ease-in-out infinite;
        }

        @keyframes title-float {

            0%,
            100% {
                transform: rotateX(15deg) rotateY(0deg) translateY(0);
            }

            50% {
                transform: rotateX(12deg) rotateY(2deg) translateY(-8px);
            }
        }
    </style>

    <!-- Loading -->
    <div id="loader">
        <h1>åŠ¨ç‰©å›­é‡Œæœ‰ä»€ä¹ˆ</h1>
        <p>æ­£åœ¨ç”Ÿæˆä¸–ç•Œ...</p>
    </div>

    <!-- Cursor -->
    <div id="cursor"></div>

    <!-- Ship Instructions -->

    <!-- Shared SVG definition for reuse -->
    <svg style="display: none;">
        <symbol id="voxel-ship-icon" viewBox="0 0 100 100">
            <!-- Hull (Brown) -->
            <path d="M20,60 L80,60 L90,50 L10,50 Z" fill="#8D6E63" stroke="#5D4037" stroke-width="2" /> <!-- Deck -->
            <path d="M20,60 L80,60 L85,75 L15,75 Z" fill="#6D4C41" stroke="#4E342E" stroke-width="2" /> <!-- Side -->
            <path d="M80,60 L90,50 L95,60 L85,75 Z" fill="#5D4037" stroke="#3E2723" stroke-width="2" /> <!-- Stern -->

            <!-- Mast (Dark Wood) -->
            <rect x="58" y="20" width="4" height="45" fill="#4E342E" stroke="#3E2723" stroke-width="1" />

            <!-- Sail (White) -->
            <path d="M62,22 L90,35 L62,48 Z" fill="#FFF8E1" stroke="#F5F5F5" stroke-width="1" />

            <!-- Water Ripples (Blue) -->
            <path d="M10,75 Q25,80 40,75 T70,75 T90,78" fill="none" stroke="#B3E5FC" stroke-width="3" opacity="0.6" />
            <path d="M5,78 Q20,83 35,78 T65,78 T85,81" fill="none" stroke="#E1F5FE" stroke-width="2" opacity="0.4" />
        </symbol>
    </svg>

    <div class="ship-container left">
        <div class="ship-flag">
            <div class="flag-content">ç‚¹å‡»å²›å±¿æ¢ç´¢</div>
        </div>
        <svg class="ship-svg">
            <use href="#voxel-ship-icon"></use>
        </svg>
    </div>

    <div class="ship-container right">
        <!-- Text is mirrored back in CSS -->
        <div class="ship-flag">
            <div class="flag-content">æ‹–æ‹½æ—‹è½¬è§†è§’</div>
        </div>
        <svg class="ship-svg">
            <use href="#voxel-ship-icon"></use>
        </svg>
    </div>

    <!-- RPG Dialog UI -->
    <div id="overlay-mask"></div> <!-- ç‚¹å‡»æ­¤å¤„é€€å‡ºèšç„¦ -->
    <div id="game-ui">
        <div id="ui-avatar-container">
            <img id="ui-avatar" src="" alt="Project Cover">
        </div>
        <div id="ui-content">
            <h2 id="ui-title">Title</h2>
            <p id="ui-desc"></p>
            <a href="#" id="ui-btn" target="_blank">[ OPEN DEMO ] â–¶</a>
        </div>
        <div id="ui-close">X</div>
    </div>

    <!-- Scripts -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. DATA STRUCTURE (æ•°æ®é…ç½®) ---
        // ä½ å¯ä»¥åœ¨è¿™é‡ŒæŠŠ 'cover' æ¢æˆçœŸå®çš„ GIF é“¾æ¥ï¼ŒæŠŠ 'link' æ¢æˆçœŸå®çš„ HTML è·¯å¾„
        const projects = [
            {
                // Center Island
                x: 0, z: 0, type: 'lighthouse',
                name: "Merry Christmas",
                description: "Merry Christmas to you guys, enjoy your life and have fun.",
                cover: "./images/christmas.png",
                link: "https://explore.boluopets.com/merry-christmas.html",
                themeColor: '#FF6B6B',
                ready: true  // â³ æœªé…ç½®
            },
            {
                // Left Island
                x: -14, z: 8, type: 'palm',
                name: "Coco Adventure",
                description: "A relaxing web-based farming simulator. Grow coconuts, trade with crabs, and chill.",
                cover: "https://placehold.co/150x150/4ECDC4/FFFFFF/png?text=Coco",
                link: "#",
                themeColor: '#4ECDC4',
                ready: false  // â³ æœªé…ç½®
            },
            {
                // Right Island
                x: 14, z: 6, type: 'cabin',
                name: "Lodge.io SaaS",
                description: "Booking management platform for remote cabins. Includes calendar and payment integration.",
                cover: "https://placehold.co/150x150/FFD93D/000000/png?text=Lodge",
                link: "#",
                themeColor: '#FFD93D',
                ready: false  // â³ æœªé…ç½®
            },
            {
                // Front Island
                x: 5, z: -14, type: 'windmill',
                name: "Eco Landing",
                description: "Award-winning landing page for renewable energy startup. High performance 3D visuals.",
                cover: "https://placehold.co/150x150/95E1D3/000000/png?text=Eco",
                link: "#",
                themeColor: '#95E1D3',
                ready: false  // â³ æœªé…ç½®
            },
            {
                // Back-Left Island (æ–°å¢)
                x: -10, z: -12, type: 'ruins',
                name: "Ancient Archive",
                description: "A mysterious knowledge base preserving forgotten wisdom. Explore the digital ruins.",
                cover: "https://placehold.co/150x150/9B59B6/FFFFFF/png?text=Ruins",
                link: "#",
                themeColor: '#9B59B6',
                ready: false  // â³ æœªé…ç½®
            },
            {
                // Far-Right Island (æ–°å¢)
                x: 16, z: -8, type: 'palm',
                name: "Tropical Studio",
                description: "Creative workspace for designers and artists. Inspiration flows like ocean breeze.",
                cover: "https://placehold.co/150x150/E67E22/FFFFFF/png?text=Studio",
                link: "#",
                themeColor: '#E67E22',
                ready: false  // â³ æœªé…ç½®
            }
        ];

        // --- 2. SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0xC4E0E5, 40, 150);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const initialCamPos = { x: 0, y: 40, z: 70 };
        camera.position.set(initialCamPos.x, initialCamPos.y, initialCamPos.z);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.1;
        controls.minDistance = 10;
        controls.maxDistance = 120;

        // Custom Cursor Logic
        const cursor = document.getElementById('cursor');
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();

        document.addEventListener('mousemove', (e) => {
            cursor.style.left = e.clientX + 'px';
            cursor.style.top = e.clientY + 'px';

            // FIXED: Correct NDC calculation for Three.js
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1; // +1 is correct for top-left origin
        });

        // --- 3. LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 0.9);
        sunLight.position.set(50, 80, 30);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.left = -60;
        sunLight.shadow.camera.right = 60;
        sunLight.shadow.camera.top = 60;
        sunLight.shadow.camera.bottom = -60;
        sunLight.shadow.radius = 2;
        scene.add(sunLight);

        // --- 4. OCEAN ---
        const seabed = new THREE.Mesh(
            new THREE.PlaneGeometry(300, 300).rotateX(-Math.PI / 2),
            new THREE.MeshBasicMaterial({ color: 0x1a5c7a })
        );
        seabed.position.y = -5;
        scene.add(seabed);

        const waterGeometry = new THREE.PlaneGeometry(200, 200, 60, 60).rotateX(-Math.PI / 2);
        const waterPos = waterGeometry.attributes.position;
        const waterInitPos = [];
        for (let i = 0; i < waterPos.count; i++) {
            waterInitPos.push({ x: waterPos.getX(i), y: waterPos.getY(i), z: waterPos.getZ(i) });
        }
        const water = new THREE.Mesh(
            waterGeometry,
            new THREE.MeshPhysicalMaterial({
                color: 0x29C2E3, roughness: 0.4, metalness: 0, reflectivity: 0.1,
                transmission: 0.8, transparent: true, opacity: 0.85, flatShading: true, side: THREE.DoubleSide
            })
        );
        water.receiveShadow = true;
        scene.add(water);

        // --- 5. TEXTURE & ISLAND GENERATION ---
        function createInfoTexture(title, description, color, ready = true) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // æœªé…ç½®å²›å±¿ä½¿ç”¨ç°è‰²ä¸»é¢˜
            const bgColor = ready ? color : '#808080';
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, 512, 512);

            // è¾¹æ¡†
            ctx.strokeStyle = ready ? '#ffffff' : '#555555';
            ctx.lineWidth = 20;
            ctx.strokeRect(20, 20, 472, 472);

            // åœˆåœˆè£…é¥°
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.beginPath();
            ctx.arc(256, 180, 100, 0, Math.PI * 2);
            ctx.fill();

            // æ ‡é¢˜æ–‡å­—
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 60px "Courier New"';
            ctx.textAlign = 'center';
            ctx.shadowColor = "rgba(0,0,0,0.3)";
            ctx.shadowBlur = 4;

            if (ready) {
                ctx.fillText(title.toUpperCase(), 256, 350);
                ctx.font = '30px "Courier New"';
                ctx.fillText(description.substring(0, 20) + "...", 256, 400);
            } else {
                // æœªé…ç½®å²›å±¿æ˜¾ç¤º COMING SOON
                ctx.fillText('COMING', 256, 320);
                ctx.fillText('SOON', 256, 390);
                ctx.font = '28px "Courier New"';
                ctx.fillStyle = '#cccccc';
                ctx.fillText(title, 256, 440);
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        const islands = [];
        const islandGroup = new THREE.Group();
        scene.add(islandGroup);

        const materials = {
            sand: new THREE.MeshLambertMaterial({ color: 0xE6C288 }),
            grass: new THREE.MeshLambertMaterial({ color: 0x8BC34A }),
            wood: new THREE.MeshStandardMaterial({ color: 0x8D6E63 }),
            stone: new THREE.MeshStandardMaterial({ color: 0x9E9E9E }),
            white: new THREE.MeshStandardMaterial({ color: 0xFFFFFF }),
            red: new THREE.MeshStandardMaterial({ color: 0xEF5350 }),
            leaf: new THREE.MeshStandardMaterial({ color: 0x66BB6A })
        };

        // å¯åŠ¨ç”»å¯¹è±¡è¿½è¸ªæ•°ç»„
        const animatables = [];

        // è¾…åŠ©å‡½æ•°ï¼šåˆ›å»ºå¸¦é˜´å½±çš„ç›’å­
        function createBox(w, h, d, color, x, y, z) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshStandardMaterial({ color: color, flatShading: true });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        // ç²¾ç»†åœ°æ ‡ï¼šçº¢ç™½æ¡çº¹ç¯å¡”
        function buildLighthouse() {
            const group = new THREE.Group();
            // çº¢ç™½æ¡çº¹å¡”èº«
            group.add(createBox(1.5, 1, 1.5, 0xFFFFFF, 0, 0.5, 0));
            group.add(createBox(1.3, 1, 1.3, 0xD64541, 0, 1.5, 0));
            group.add(createBox(1.1, 1, 1.1, 0xFFFFFF, 0, 2.5, 0));
            group.add(createBox(0.9, 1, 0.9, 0xD64541, 0, 3.5, 0));
            // é¡¶éƒ¨å‘å…‰ç¯
            const lampGeo = new THREE.BoxGeometry(1.2, 0.8, 1.2);
            const lampMat = new THREE.MeshStandardMaterial({ color: 0xFFD93D, emissive: 0xFFD700, emissiveIntensity: 0.5 });
            const lamp = new THREE.Mesh(lampGeo, lampMat);
            lamp.position.y = 4.4;
            group.add(lamp);
            return group;
        }

        // ç²¾ç»†åœ°æ ‡ï¼šå¼¯æ›²æ£•æ¦ˆæ ‘
        function buildPalmTree() {
            const group = new THREE.Group();
            // å¼¯æ›²æ ‘å¹²ï¼ˆé€šè¿‡åç§»å †å æ¨¡æ‹Ÿï¼‰
            group.add(createBox(0.6, 1.2, 0.6, 0x8B4513, 0, 0.6, 0));
            group.add(createBox(0.5, 1.2, 0.5, 0x8B4513, 0.2, 1.6, 0));
            group.add(createBox(0.4, 1.2, 0.4, 0x8B4513, 0.5, 2.6, 0));

            // 6 ç‰‡æ—‹è½¬æ ‘å¶
            const leavesGroup = new THREE.Group();
            leavesGroup.position.set(0.5, 3.2, 0);
            const leafGeo = new THREE.BoxGeometry(2.5, 0.2, 0.8);
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x27ae60 });

            [0, 60, 120, 180, 240, 300].forEach(deg => {
                const leaf = new THREE.Mesh(leafGeo, leafMat);
                leaf.rotation.y = deg * Math.PI / 180;
                leaf.rotation.z = Math.PI / 6; // å¾®å¾®ä¸‹å‚
                leavesGroup.add(leaf);
            });
            group.add(leavesGroup);
            return group;
        }

        // ç²¾ç»†åœ°æ ‡ï¼šå°æœ¨å±‹
        function buildCabin() {
            const group = new THREE.Group();
            // æœ¨å±‹ä¸»ä½“
            group.add(createBox(2.2, 1.5, 1.8, 0x8B4513, 0, 0.75, 0));
            // é—¨
            group.add(createBox(0.6, 1, 0.1, 0x4a3c31, 0, 0.5, 0.9));
            // æ£±é”¥å±‹é¡¶
            const roofGeo = new THREE.ConeGeometry(2, 1, 4);
            const roofMat = new THREE.MeshStandardMaterial({ color: 0xA0522D, flatShading: true });
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.position.y = 2.0;
            roof.rotation.y = Math.PI / 4;
            roof.scale.z = 0.8;
            group.add(roof);
            // çƒŸå›±
            group.add(createBox(0.4, 0.8, 0.4, 0x555555, 0.8, 2.0, -0.4));
            return group;
        }

        // ç²¾ç»†åœ°æ ‡ï¼šé£è½¦ï¼ˆå¸¦æ—‹è½¬å¶ç‰‡ï¼‰
        function buildWindmill() {
            const group = new THREE.Group();
            // é£è½¦ä¸»ä½“
            group.add(createBox(1.5, 2, 1.5, 0xEEEEEE, 0, 1, 0));
            // æ©™è‰²å±‹é¡¶
            const roofGeo = new THREE.ConeGeometry(1.2, 1, 4);
            const roofMat = new THREE.MeshStandardMaterial({ color: 0xD35400 });
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.position.y = 2.5;
            roof.rotation.y = Math.PI / 4;
            group.add(roof);

            // å¯æ—‹è½¬å¶ç‰‡ç»„
            const blades = new THREE.Group();
            blades.position.set(0, 2, 0.8);

            const bladeGeo = new THREE.BoxGeometry(0.3, 3.5, 0.1);
            const bladeMat = new THREE.MeshStandardMaterial({ color: 0xF1C40F });
            const b1 = new THREE.Mesh(bladeGeo, bladeMat);
            const b2 = new THREE.Mesh(bladeGeo, bladeMat);
            b2.rotation.z = Math.PI / 2;
            blades.add(b1);
            blades.add(b2);

            group.add(blades);

            // æ ‡è®°ä¸ºå¯åŠ¨ç”»å¯¹è±¡
            group.userData.animatable = true;
            group.userData.blades = blades;

            return group;
        }

        // ç²¾ç»†åœ°æ ‡ï¼šåºŸå¢Ÿï¼ˆå¸¦æ¼‚æµ®æ°´æ™¶ï¼‰
        function buildRuins() {
            const group = new THREE.Group();
            // é«˜ä½ä¸ä¸€çš„çŸ³æŸ±
            group.add(createBox(0.5, 2.5, 0.5, 0x95A5A6, -0.8, 1.25, -0.8));
            group.add(createBox(0.5, 1.5, 0.5, 0x95A5A6, 0.8, 0.75, 0.8));
            group.add(createBox(0.5, 0.5, 0.5, 0x95A5A6, -0.8, 0.25, 0.8)); // æ®‹ç ´çš„
            // æ¼‚æµ®å‘å…‰æ°´æ™¶
            const crysGeo = new THREE.OctahedronGeometry(0.4);
            const crysMat = new THREE.MeshStandardMaterial({ color: 0x9B59B6, emissive: 0x8E44AD, emissiveIntensity: 0.8 });
            const crystal = new THREE.Mesh(crysGeo, crysMat);
            crystal.position.set(0, 2, 0);

            // æ ‡è®°ä¸ºå¯åŠ¨ç”»å¯¹è±¡
            group.userData.animatable = true;
            group.userData.crystal = crystal;
            group.add(crystal);

            return group;
        }

        function createIsland(projectData, index) {
            const { x, z, type, name, description, themeColor } = projectData;
            const group = new THREE.Group();

            // Attach project data to the 3D object for retrieval on click
            group.userData = {
                id: index,
                isIsland: true,
                project: projectData, // Store full data
                floatOffset: Math.random() * Math.PI * 2,
                floatSpeed: 0.8 + Math.random() * 0.4
            };

            // Base
            const baseSize = 8;
            const sand = new THREE.Mesh(new THREE.BoxGeometry(baseSize, 3, baseSize), materials.sand);
            sand.position.y = -1.5; sand.receiveShadow = true;
            group.add(sand);

            // è‰åœ°é¢œè‰²ï¼šå·²é…ç½®ç»¿è‰²ï¼Œæœªé…ç½®ç°è‰²
            const grassMat = projectData.ready
                ? materials.grass
                : new THREE.MeshLambertMaterial({ color: 0x9E9E9E });
            const grass = new THREE.Mesh(new THREE.BoxGeometry(baseSize - 0.5, 0.6, baseSize - 0.5), grassMat);
            grass.position.y = 0.3; grass.receiveShadow = true; grass.castShadow = true;
            group.add(grass);

            // Billboard
            const boardGroup = new THREE.Group();
            boardGroup.position.set(2, 2.5, 2);
            boardGroup.rotation.y = -Math.PI / 6;
            const postGeo = new THREE.BoxGeometry(0.2, 3, 0.2);
            const post1 = new THREE.Mesh(postGeo, materials.wood); post1.position.x = -1.5;
            const post2 = new THREE.Mesh(postGeo, materials.wood); post2.position.x = 1.5;
            boardGroup.add(post1, post2);

            const boardMat = new THREE.MeshStandardMaterial({
                map: createInfoTexture(name, description, themeColor, projectData.ready), roughness: 0.6
            });
            const board = new THREE.Mesh(new THREE.BoxGeometry(3.4, 2.2, 0.2), boardMat);
            board.position.y = 1; board.castShadow = true;
            boardGroup.add(board);
            group.add(boardGroup);

            // Landmark - ä½¿ç”¨ç²¾ç»†åœ°æ ‡å‡½æ•°
            let landmark;
            switch (type) {
                case 'lighthouse': landmark = buildLighthouse(); break;
                case 'palm': landmark = buildPalmTree(); break;
                case 'cabin': landmark = buildCabin(); break;
                case 'windmill': landmark = buildWindmill(); break;
                case 'ruins': landmark = buildRuins(); break;
                default: landmark = buildCabin();
            }
            landmark.position.set(-1.5, 0.6, -1.5);

            // å¦‚æœåœ°æ ‡æœ‰åŠ¨ç”»å±æ€§ï¼Œæ·»åŠ åˆ°å¯åŠ¨ç”»å¯¹è±¡æ•°ç»„
            if (landmark.userData.animatable) {
                animatables.push(landmark);
            }
            // é£è½¦å¶ç‰‡å¼•ç”¨åˆ°å²›å±¿ groupï¼ˆä¿ç•™åŸæœ‰é€»è¾‘å…¼å®¹ï¼‰
            if (landmark.userData.blades) {
                group.userData.blades = landmark.userData.blades;
            }
            group.add(landmark);

            group.position.set(x, 800, z); // Start high for drop
            islandGroup.add(group);
            islands.push(group);
            return group;
        }

        // Generate islands from PROJECTS data
        projects.forEach((data, i) => createIsland(data, i));

        // Bridges (Simplified connection logic)
        function createBridges() {
            const center = islands[0];
            const others = islands.slice(1);
            const plankGeo = new THREE.BoxGeometry(1.0, 0.1, 0.4);
            others.forEach(target => {
                const start = new THREE.Vector3(center.position.x, 0.5, center.position.z);
                const end = new THREE.Vector3(target.position.x, 0.5, target.position.z);
                const dist = start.distanceTo(end);
                const steps = Math.floor(dist / 0.8);
                const dir = new THREE.Vector3().subVectors(end, start).normalize();
                for (let k = 2; k < steps - 2; k++) {
                    const plank = new THREE.Mesh(plankGeo, materials.wood);
                    const pos = new THREE.Vector3().copy(start).add(dir.clone().multiplyScalar(k * 0.8));
                    const sag = Math.sin((k / steps) * Math.PI) * -1.0;
                    plank.position.set(pos.x, 1.0 + sag, pos.z);
                    plank.lookAt(end); plank.castShadow = true;
                    plank.userData.isPlank = true; plank.userData.finalY = plank.position.y; plank.position.y += 800;
                    islandGroup.add(plank); islands.push(plank);
                }
            });
        }
        createBridges();

        // Clouds (Decor)
        const cloudGeo = new THREE.BoxGeometry(1, 1, 1);
        const cloudMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.8 });
        const clouds = [];
        for (let i = 0; i < 8; i++) {
            const cGroup = new THREE.Group();
            for (let j = 0; j < 5; j++) {
                const m = new THREE.Mesh(cloudGeo, cloudMat);
                m.position.set((Math.random() - 0.5) * 4, (Math.random() - 0.5) * 1.5, (Math.random() - 0.5) * 2);
                m.scale.setScalar(Math.random() * 1.5 + 0.5); cGroup.add(m);
            }
            cGroup.position.set((Math.random() - 0.5) * 120, 25 + Math.random() * 15, (Math.random() - 0.5) * 80);
            scene.add(cGroup); clouds.push({ mesh: cGroup, speed: 0.01 + Math.random() * 0.02 });
        }

        // --- 6. INTERACTION LOGIC (The RPG System) ---
        let isExploring = false; // State flag
        let typeWriterInterval;

        const ui = {
            container: document.getElementById('game-ui'),
            avatar: document.getElementById('ui-avatar'),
            title: document.getElementById('ui-title'),
            desc: document.getElementById('ui-desc'),
            btn: document.getElementById('ui-btn'),
            close: document.getElementById('ui-close'),
            mask: document.getElementById('overlay-mask')
        };

        // Click Handler
        window.addEventListener('click', onMouseClick);

        function onMouseClick(event) {
            // Check if clicking UI elements - if so, don't trigger scene logic
            if (event.target.closest('#game-ui')) return;

            // If exploring, clicking mask or outside UI resets view
            if (isExploring) {
                resetView();
                return;
            }

            // Raycast for Island
            // Update mouse coordinates for accuracy on click
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(islandGroup.children, true);

            if (intersects.length > 0) {
                // Find parent group
                let target = intersects[0].object;
                while (target && !target.userData.isIsland) {
                    target = target.parent;
                }

                if (target && target.userData.project) {
                    focusIsland(target);
                }
            }
        }

        // Focus Animation
        function focusIsland(islandGroup) {
            isExploring = true;
            ui.mask.classList.add('active'); // Enable overlay mask to catch clicks

            // èƒŒæ™¯æ¨¡ç³Šæ•ˆæœ
            renderer.domElement.classList.add('blurred');

            // Calculate Camera Target Position
            // We want to look at the island from slightly in front and above
            const offset = { x: 0, y: 15, z: 25 };
            // Add island position
            const targetPos = {
                x: islandGroup.position.x + offset.x,
                y: islandGroup.position.y + offset.y,
                z: islandGroup.position.z + offset.z
            };

            // 1. Animate Camera Position
            gsap.to(camera.position, {
                x: targetPos.x,
                y: targetPos.y,
                z: targetPos.z,
                duration: 1.5,
                ease: "power2.inOut"
            });

            // 2. Animate Controls Target (LookAt)
            gsap.to(controls.target, {
                x: islandGroup.position.x,
                y: islandGroup.position.y + 2, // Look slightly up at the building
                z: islandGroup.position.z,
                duration: 1.5,
                ease: "power2.inOut",
                onComplete: () => {
                    showDialog(islandGroup.userData.project);
                }
            });
        }

        // Reset Animation
        function resetView() {
            isExploring = false;
            hideDialog();
            ui.mask.classList.remove('active');

            // ç§»é™¤èƒŒæ™¯æ¨¡ç³Šæ•ˆæœ
            renderer.domElement.classList.remove('blurred');

            // 1. Animate Camera back to overview
            gsap.to(camera.position, {
                x: initialCamPos.x,
                y: initialCamPos.y,
                z: initialCamPos.z,
                duration: 1.2,
                ease: "power2.inOut"
            });

            // 2. Reset LookAt
            gsap.to(controls.target, {
                x: 0, y: 0, z: 0,
                duration: 1.2,
                ease: "power2.inOut"
            });
        }

        // UI Logic
        function showDialog(project) {
            ui.container.classList.add('active');

            // Set Content
            ui.title.innerText = project.name;
            ui.avatar.src = project.cover;

            // æ ¹æ® ready çŠ¶æ€æ§åˆ¶æŒ‰é’®
            if (project.ready) {
                ui.btn.href = project.link;
                ui.btn.innerText = '[ OPEN DEMO ] â–¶';
                ui.btn.style.background = '#4a3c31';
                ui.btn.style.cursor = 'pointer';
                ui.btn.style.pointerEvents = 'auto';
            } else {
                ui.btn.href = '#';
                ui.btn.innerText = '[ COMING SOON ]';
                ui.btn.style.background = '#888888';
                ui.btn.style.cursor = 'not-allowed';
                ui.btn.style.pointerEvents = 'none';
            }

            // Typewriter Effect
            ui.desc.innerText = "";
            ui.desc.classList.add('typing-cursor');
            const text = project.ready
                ? project.description
                : 'ğŸš§ ' + project.description + ' (å³å°†ä¸Šçº¿)';
            let i = 0;
            clearInterval(typeWriterInterval);

            typeWriterInterval = setInterval(() => {
                if (i < text.length) {
                    ui.desc.innerText += text.charAt(i);
                    i++;
                } else {
                    clearInterval(typeWriterInterval);
                    ui.desc.classList.remove('typing-cursor'); // æ‰“å­—å®Œæˆåç§»é™¤å…‰æ ‡
                }
            }, 30); // 30ms per char
        }

        function hideDialog() {
            ui.container.classList.remove('active');
            clearInterval(typeWriterInterval);
        }

        // Close button listener
        ui.close.addEventListener('click', resetView);
        ui.mask.addEventListener('click', resetView);


        // --- 7. ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function startIntro() {
            gsap.to("#loader", { opacity: 0, duration: 0.8, onComplete: () => document.getElementById('loader').style.display = 'none' });
            islands.forEach((obj, i) => {
                const targetY = obj.userData.isPlank ? obj.userData.finalY : 0;
                gsap.to(obj.position, {
                    y: targetY, duration: 2.0, ease: "elastic.out(1, 0.5)", delay: i * 0.03
                });
            });
        }
        setTimeout(startIntro, 100);

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // Water
            for (let i = 0; i < waterPos.count; i++) {
                const x = waterInitPos[i].x; const y = waterInitPos[i].y;
                let z = Math.sin(x * 0.1 + time * 0.8) * Math.cos(y * 0.1 + time * 0.8) * 0.5;
                z += Math.sin(x * 0.3 - time * 1.5) * 0.3;
                z += Math.cos(y * 0.5 + time * 2.0) * 0.1;
                waterPos.setZ(i, z);
            }
            waterPos.needsUpdate = true;
            waterGeometry.computeVertexNormals();

            // Island Float & Raycasting (Only when not exploring)
            raycaster.setFromCamera(mouse, camera);
            // Only raycast if NOT exploring to save perf and avoid hover effects during dialog
            let intersects = [];
            if (!isExploring) {
                intersects = raycaster.intersectObjects(islandGroup.children, true);
            }

            islands.forEach(obj => {
                if (obj.userData.isPlank) return;

                // Float physics - å¢å¤§æ‚¬æµ®å¹…åº¦
                if (obj.position.y < 10) {
                    const floatY = Math.sin(time * obj.userData.floatSpeed + obj.userData.floatOffset) * 0.4;
                    if (time > 3) obj.position.y = floatY;
                }
                if (obj.userData.blades) obj.userData.blades.rotation.z -= 0.03;
            });

            // Animatables åŠ¨ç”»å¾ªç¯ - é£è½¦æ—‹è½¬ + æ°´æ™¶æ¼‚æµ®
            animatables.forEach(item => {
                if (item.userData.blades) {
                    item.userData.blades.rotation.z -= 0.02;
                }
                if (item.userData.crystal) {
                    item.userData.crystal.rotation.y += 0.01;
                    item.userData.crystal.position.y = 2 + Math.sin(time * 2) * 0.2;
                }
            });

            islands.forEach(obj => {
                if (obj.userData.isPlank) return;

                // Hover Logic
                let isHovered = false;
                if (!isExploring && intersects.length > 0) {
                    let parent = intersects[0].object;
                    while (parent) {
                        if (parent === obj) { isHovered = true; break; }
                        parent = parent.parent;
                    }
                }

                if (isHovered) {
                    const targetRotX = mouse.y * 0.15;
                    const targetRotZ = mouse.x * 0.15;
                    obj.rotation.x += (targetRotX - obj.rotation.x) * 0.1;
                    obj.rotation.z += (-targetRotZ - obj.rotation.z) * 0.1;
                    obj.scale.setScalar(1.1);
                    cursor.style.transform = `translate(-50%, -50%) scale(1.5)`;
                    cursor.style.opacity = '1';
                } else {
                    obj.rotation.x *= 0.9;
                    obj.rotation.z *= 0.9;
                    obj.scale.setScalar(1.0);
                }
            });

            if (!isExploring && intersects.length === 0) {
                cursor.style.transform = `translate(-50%, -50%) scale(1)`;
                cursor.style.opacity = '0.7';
            } else if (isExploring) {
                cursor.style.opacity = '1'; // Show cursor clearly during UI
                cursor.style.transform = `translate(-50%, -50%) scale(1)`;
            }

            // Clouds
            clouds.forEach(c => {
                c.mesh.position.x += c.speed;
                if (c.mesh.position.x > 100) c.mesh.position.x = -100;
            });

            // Camera Drift (Only when not exploring)
            if (!isExploring) {
                camera.position.x += (mouse.x * 2 - camera.position.x + initialCamPos.x) * 0.02;
                camera.position.y += ((initialCamPos.y + mouse.y * 2) - camera.position.y) * 0.02;
                camera.lookAt(0, 0, 0);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>